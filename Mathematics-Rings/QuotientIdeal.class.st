"
Ideals of quotient rings.
"
Class {
	#name : #QuotientIdeal,
	#superclass : #Ideal,
	#category : #'Mathematics-Rings'
}

{ #category : #operations }
QuotientIdeal >> dot: anIdeal [
	"Answer the intersection of the receiver and the argument."
	^ self representative dot: anIdeal representative / self scalars relations
]

{ #category : #'operations-elements' }
QuotientIdeal >> inverseOf: anElement [
	^ self scalars project: (self representative inverseOf: anElement representative)
]

{ #category : #testing }
QuotientIdeal >> isPrime [
	^ self representative isPrime
]

{ #category : #testing }
QuotientIdeal >> isPrincipal [
	"Answer true if the receiver is generated by a single element."
	^ self representative isPrincipal
]

{ #category : #printing }
QuotientIdeal >> printOn: aStream [
	self isZero ifTrue: [aStream nextPut: ${; print: self scalars zero; nextPut: $}. ^ self].
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [aStream print: self generator; print: self scalars. ^ self].
	super printOn: aStream
]

{ #category : #operations }
QuotientIdeal >> quot: anIdeal [
	"Answer the colon quotient I:J of the receiver I with the argument J."
	^ 'self representative Ëœ anIdeal representative / self scalars relations'
]

{ #category : #operations }
QuotientIdeal >> radical [
	^ self representative radical / self scalars relations
]

{ #category : #'operations-elements' }
QuotientIdeal >> reduce: anElement [
	"Answer the normal form of anElement with respect to the receiver."
	^ self scalars project: (self representative reduce: anElement representative)
]

{ #category : #accessing }
QuotientIdeal >> representative [
	"If the receiver is an ideal I of a quotient ring A/J, return the lifting of I to A, this is the ideal in A generated by the representatives in A of the generators of I."
	^ self propertyAt: #representative ifAbsentPut: [self scalars base * (self generators collect: [:each| each representative]) + self scalars relations]
]
