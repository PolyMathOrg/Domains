"
Rings with unit, i.e. structures with a set R of elements, a distinguished element 1 (the multiplicative identity) and two binary operations + and * such that:
- R is an abelian group under addition;
- R is a monoid under multiplication;
- multiplication is distributive with respect to addition.

The idea of 'ring' appears naturally in mathematics when considering the endomorphisms of abelian groups (or other abelian categories) under composition. In some sense, that's the essence of rings.

Rings can be commutative or non-commutative. Some specific kinds of commutative rings are given with the following class of inclusions:
	commutative rings > integral domains > integrity closed domains > unique factorization domains > principal ideal domains > euclidean domains > fields > finite fields.

Rings can be constructed from existing rings by taking quotients by an ideal (see QuotientRing), by making transcendental extensions (see PolynomialRing), etc.

Rings can also be made into fields by 'adding the missing multiplicative inverses' (or localization), for example by constructing the fractions of an integral domain (see FractionRing and LocalizationRing).

References:
	https://en.wikipedia.org/wiki/Ring_(mathematics)
"
Class {
	#name : #Ring,
	#superclass : #Semiring,
	#category : #'Mathematics-Rings'
}

{ #category : #elements }
Ring >> ! anObject [
	anObject isInteger
		ifTrue: [ ^ self one * anObject ].
	anObject isFraction
		ifTrue:
			[ ^ self one * anObject numerator / (self one * anObject denominator) ].
	(anObject isKindOf: Ideal)
		ifTrue: [ ^ self * (anObject generators collect: [ :each | self ! each ]) ].
	^ super ! anObject
]

{ #category : #operations }
Ring >> * anElementOrArray [
	"Answer the ideal generated by the argument."
	(self includes: anElementOrArray)
		ifTrue: [^ self idealClass over: self generators: {anElementOrArray}].
	anElementOrArray isCollection
		ifTrue: [^ self idealClass over: self generators: anElementOrArray].
	^ self * (self ! anElementOrArray)
]

{ #category : #operations }
Ring >> / anIdeal [
	"Answer the quotient by the given ideal.
	For convenience, the argument can be a single element or a collection of elements as well."
	| I |
	(anIdeal isKindOf: Ideal)
		ifTrue:
			[self = anIdeal scalars ifFalse: [^ DomainError signal: 'ideal belongs to a different ring'].
			I := anIdeal]
		ifFalse:
			[I := self * anIdeal].
	^ I quotientRing
]

{ #category : #operations }
Ring >> algebraicClosure [
	self isAlgebraicallyClosed ifTrue: [^ self].
	^ self propertyAt: #algebraicClosure
]

{ #category : #converting }
Ring >> asAbelianGroup [
	^ self as: AbelianGroup
]

{ #category : #converting }
Ring >> asIdeal [
	"Answer the receiver R viewed as an ideal of itself."
	^ self * self one
]

{ #category : #converting }
Ring >> asSelfModule [
	"Answer the receiver R viewed as R-module."
	^ RingAsModule over: self
]

{ #category : #morphisms }
Ring >> conjugation [
	"Answer the companion automorphism of the receiver."
	^ self id
]

{ #category : #operations }
Ring >> cyclotomicRing: n [
	"Answer the n-th cyclotomic ring on the receiver."
	| Fx phi |
	Fx := self polynomials.
	phi := Fx cyclotomic: n. "cyclotomic polynomial of order n"
	^ Fx / phi "answer the quotient ring modulo <phi>"
]

{ #category : #accessing }
Ring >> dimension [
	"Answer the Krull dimension of the receiver."
	self isField ifTrue: [^ 0].
	self isPID ifTrue: [^ 1].
	self isIntegralDomain ifTrue: [^ 1].
	self isDedekindDomain ifTrue: [^ 1].
	^ self propertyAt: #dimension
]

{ #category : #morphisms }
Ring >> embedding [
	^ ZZ to: self evaluating: [:x| self one * x]
]

{ #category : #operations }
Ring >> extension: aPolynomial [
	"Answer the algebraic extension of the receiver defined by the given irreducible polynomial."
"	self isField ifFalse: [DomainError signal: 'not a field']."
	aPolynomial scalars = self ifFalse: [DomainError signal: 'polynomial coefficients not from this ring'].
	aPolynomial parent isUnivariate ifFalse: [DomainError signal: 'not univariate poylnomial'].
	^ AlgebraicExtension polynomial: aPolynomial
]

{ #category : #operations }
Ring >> extensionDegree: anInteger [
	"Answer the algebraic extension of the receiver of the given degree. Choose any irreducible polynomial."
	^ self extension: (self polynomials findIrreducibleOfDegree: anInteger)
]

{ #category : #private }
Ring >> fractionalIdealClass [
	^ FractionalIdeal
]

{ #category : #operations }
Ring >> fractions [
	"Answer the fraction ring of the receiver. If the receiver is an integral domain, the fraction ring will be a field."
	self isField ifTrue: [^ self].
	^ self propertyAt: #fractions ifAbsentPut: [FractionRing on: self]
]

{ #category : #operations }
Ring >> freeAlgebra [
	^ FreeAlgebra over: self
]

{ #category : #operations }
Ring >> freeAlgebraIn: anIntegerOrCollection [
	"Answer the free algebra in the given indeterminates over the receiver."
	anIntegerOrCollection isInteger ifTrue: [^ FreeAlgebra new: anIntegerOrCollection over: self].
	^ FreeAlgebra on: anIntegerOrCollection over: self
]

{ #category : #operations }
Ring >> freeModuleIn: aCollection [
	"Answer the free module in the given indeterminates over the receiver."
	^ FormalSumsModule on: aCollection over: self
]

{ #category : #morphisms }
Ring >> frobenius [
	"Answer the Frobenius endomorphism, assuming the receiver is of characteristic p prime."
	| p |
	p := self characteristic.
	^ self to: self evaluating: 'self polynomials x ^ p'
]

{ #category : #private }
Ring >> idealClass [
	^ Ideal
]

{ #category : #operations }
Ring >> ideals [
	^ IdealSemiring on: self
]

{ #category : #enumerating }
Ring >> idealsDo: aBlock [
	^ self subclassResponsibility
]

{ #category : #'elements-matrices' }
Ring >> identityMatrix: dimension [
	^ self matrix: dimension scalar: self one
]

{ #category : #testing }
Ring >> isAlgebraicallyClosed [
	^ self propertyAt: #isAlgebraicallyClosed ifAbsent: [false]
]

{ #category : #testing }
Ring >> isArtinian [
	"Answer true if the receiver is an Artinian ring, i.e. it satisfied the descending chain condition on ideals.
	In the non-commutative case one should talk about 'left Artinian' or 'right Artinian' rings."
	self isIntegralDomain ifTrue: [^ self isField].
	self isFinite ifTrue: [^ true].
	^ self propertyAt: #isArtinian
]

{ #category : #testing }
Ring >> isCommutative [
	^ self propertyAt: #isCommutative ifAbsent: [self isIntegralDomain]
]

{ #category : #testing }
Ring >> isCompositive [
	^ self multiplication name = '@'
]

{ #category : #testing }
Ring >> isDedekindDomain [
	"A Dedekind domain is an integral domain in which every non-zero proper ideal factors into a product of prime ideals."
	^ self propertyAt: #isDedekindDomain
]

{ #category : #testing }
Ring >> isDivisionRing [
	"A division ring, or skewfield, is a ring where division is possible, i.e. every non-zero element has a multiplicative inverse. The only difference with a field is that a division ring is not requiered to be commutative."
	self isField ifTrue: [^ true].
	^ self propertyAt: #isDivisionRing ifAbsent: [false]
]

{ #category : #testing }
Ring >> isEuclidean [
	"Answer true if the receiver is an Euclidean ring, i.e. it has division with remainder."
	^ self propertyAt: #isEuclidean ifAbsent: [self isField]
]

{ #category : #testing }
Ring >> isEuclideanDomain [
	"Answer true if the receiver is an Euclidean domain, i.e. an integral domain that has division with remainder."
	^ self isIntegralDomain and: [self isEuclidean]
]

{ #category : #testing }
Ring >> isField [
	^ self propertyAt: #isField ifAbsent: [false]
]

{ #category : #testing }
Ring >> isGCDDomain [
	"A GCD domain is an integral domain with the property that any two non-zero elements have GCD (or equivalently any two non-zero elements have a LCM)."
	^ self propertyAt: #isGCDDomain
]

{ #category : #testing }
Ring >> isGaloisField [
	^ self isFinite and: [self isField]
]

{ #category : #testing }
Ring >> isGaloisRing [
	^ false
]

{ #category : #testing }
Ring >> isGlobalField [
	^ false
]

{ #category : #testing }
Ring >> isInitial [
	"In the cateogry of commutative rings with unit, the integers are the initial object. Redefined in Integers."
	^ false
]

{ #category : #testing }
Ring >> isIntegralDomain [
	"A ring is an integral domain if the product of any two non-zero elements is non-zero."
	self propertyAt: #isIntegralDomain ifPresent: [:aBoolean| ^ aBoolean].
	self isFinite ifTrue: [^ self propertyAt: #isIntegralDomain put: (self zeroDivisors allSatisfy: [:each| each isZero])].
	^ self isIntegrallyClosedDomain
]

{ #category : #testing }
Ring >> isIntegrallyClosedDomain [
	"A ring is an integrally closed domain if it is an integral domain whose integral closure in its field of fractions is the ring itself."
	^ self propertyAt: #isIntegrallyClosedDomain ifAbsent: [self isUFD]
]

{ #category : #'elements-testing' }
Ring >> isIrreducible: anElement [
	^ self subclassResponsibility
]

{ #category : #testing }
Ring >> isLocal [
	"Answer true if the receiver is a local ring. Subclasses should reimplement."
	^ self isDivisionRing
]

{ #category : #testing }
Ring >> isLocalField [
	^ false
]

{ #category : #testing }
Ring >> isLocalization [
	^ false
]

{ #category : #'elements-testing' }
Ring >> isNilpotent: anElement [
	"Answer true if anElement^n = 0 for some integer n >= 1."
	^ self nilradical contains: anElement
]

{ #category : #testing }
Ring >> isNoetherian [
	self isField ifTrue: [^ true].
	self isPID ifTrue: [^ true].
	self isDedekindDomain ifTrue: [^ true].
	^ self propertyAt: #isNoetherian
]

{ #category : #testing }
Ring >> isPID [
	"A principal ideal domain (PID) is an integral domain in which every ideal is principal, i.e. can be generated by a single element."
	^ self propertyAt: #isPID ifAbsent: [self isEuclidean]
]

{ #category : #testing }
Ring >> isPIR [
	"A principal ideal ring (PIR) is a ring in which every ideal is principal, i.e. can be generated by a single element."
	^ self propertyAt: #isPIR ifAbsent: [self isPID]
]

{ #category : #testing }
Ring >> isPerfectField [
	"A field is perfect if either it has characteristic 0 or has characteristic p and every element in the field has a p-th root in the field."
	self isField ifFalse: [^ false].
	(self characteristic = 0 or: [self isFinite]) ifTrue: [^ true].
	self isAlgebraicallyClosed ifTrue: [^ true].
	^ self propertyAt: #isPerfectField
]

{ #category : #testing }
Ring >> isReduced [
	"A ring is reduced if it has no non-zero nilpotents, i.e. if r^n = 0 for some n >> 0, then r = 0."
	self isIntegralDomain ifTrue: [^ true].
	^ self noneSatisfy: [:any| any squared isZero and: [any isZero not]]
	
"alternatively:
	^ self nilradical isZero"
]

{ #category : #testing }
Ring >> isRing [
	^ true
]

{ #category : #testing }
Ring >> isSemilocal [
	"A ring is called 'semilocal' if it contains a finite number of maximal ideals."
	self isFinite ifTrue: [^ true]. "Finite rings are semilocal."
	self isLocal ifTrue: [^ true]. "Local rings have 1 maximal ideal"
	^ self propertyAt: #isSemilocal
]

{ #category : #testing }
Ring >> isTerminal [
	^ self isTrivial
]

{ #category : #testing }
Ring >> isTrivial [
	"The trivial ring is the zero ring with a single element 0 = 1."
	^ self size = 1
]

{ #category : #testing }
Ring >> isUFD [
	"A unique factorization domain (UFD) is a commutative ring in which every non-zero non-unit element can be written as a product of prime elements (or irreducible elements), uniquely up to order and units."
	^ self propertyAt: #isUFD ifAbsent: [self isPID or: [self isEuclideanDomain]]
]

{ #category : #'elements-testing' }
Ring >> isUnit: anElement [
	"Answer true if the argument is invertible."
	| one |
	self isDivisionRing ifTrue: [^ anElement isZero not].
	self isFinite ifFalse: [^ self notYetImplemented].
	one := self one.
	^ self anySatisfy: [:any| anElement * any = one]
]

{ #category : #'elements-testing' }
Ring >> isZeroDivisor: anElement [
	"Answer true if there exists a nonzero element that multiplied by the argument is zero."
	self isIntegralDomain ifTrue: [^ anElement isZero].
	self isFinite ifFalse: [^ self notYetImplemented].
	^ self anySatisfy: [:any| any isZero not and: [(anElement * any) isZero]]
]

{ #category : #operations }
Ring >> localizationAt: aPrimeIdeal [
	"Answer the localization of the receiver at aPrimeIdeal."
	| P |
	P := (aPrimeIdeal isKindOf: Ideal)
		ifTrue:
			[self = aPrimeIdeal scalars ifFalse: [DomainError signal: 'ideal belongs to a different ring'].
			aPrimeIdeal]
		ifFalse:
			[self * aPrimeIdeal].
	^ LocalizationRing at: P
]

{ #category : #'elements-matrices' }
Ring >> matrix: aCollection [
	^ Matrix rows: (aCollection collect: [:each| self tuple: each])
]

{ #category : #'elements-matrices' }
Ring >> matrix: dimension coefficients: aCollection [
	| stream |
	stream := aCollection readStream.
	^ self matrix: dimension evaluating: [:i :j| stream next]
]

{ #category : #'elements-matrices' }
Ring >> matrix: dimension evaluating: aBlock [
	| n m |
	dimension isInteger ifTrue: [n := m := dimension] ifFalse: [n := dimension x. m := dimension y].
	^ Matrix rows: ((1 to: n) collect: [:i| self tuple: m evaluating: [:j| aBlock value: i value: j]])
]

{ #category : #'elements-matrices' }
Ring >> matrix: dimension evaluatingDiagonal: aBlock [
	| zero |
	zero := self zero.
	^ self matrix: dimension evaluating: [:i :j| i == j ifTrue: [aBlock value: i] ifFalse: [zero]]
]

{ #category : #'elements-matrices' }
Ring >> matrix: dimension scalar: anElement [
	^ self matrix: dimension evaluatingDiagonal: [:i| anElement]
]

{ #category : #accessing }
Ring >> maximalIdeal [
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isDivisionRing ifTrue: [^ self zeroIdeal].
	self subclassResponsibility
]

{ #category : #operations }
Ring >> mod: anObject [
	^ self / (self * anObject)
]

{ #category : #operations }
Ring >> nilradical [
	"Answer the ideal consisting of all nilpotent elements, i.e. all x such that there exists some n with x^n = 0. It is the intersection of all prime ideals."
	^ self zeroIdeal radical
	
"alternative:
	| answer |
	answer := self oneIdeal.
	self primeIdealsDo: [:each| answer := answer ï each].
	^ answer"
]

{ #category : #operations }
Ring >> oneIdeal [
	^ self * self one
]

{ #category : #operations }
Ring >> polynomials [
	^ self propertyAt: #polynomials ifAbsentPut: [self polynomialsIn: #(x)]
]

{ #category : #operations }
Ring >> polynomialsIn: anIntegerOrCollection [
	"Answer the ring of multivariate polynomials over the receiver in the given indeterminates."
	^ self polynomialsIn: anIntegerOrCollection ordering: #grevlex
]

{ #category : #operations }
Ring >> polynomialsIn: anIntegerOrCollection ordering: aMonomialOrdering [
	"Answer the ring of multivariate polynomials over the receiver over the given indeterminates."
	| answer |
	anIntegerOrCollection isInteger
		ifTrue: [^ PolynomialRing new: anIntegerOrCollection over: self ordering: aMonomialOrdering].
	answer := PolynomialRing new: anIntegerOrCollection size over: self ordering: aMonomialOrdering.
	answer names: anIntegerOrCollection.
	^ answer
]

{ #category : #enumerating }
Ring >> primeIdealsDo: aBlock [
	self isField ifTrue: [aBlock value: self zeroIdeal. ^ self].
	self idealsDo: [:each| each isPrime ifTrue: [aBlock value: each]]
]

{ #category : #operations }
Ring >> productRing: aRing [ "◊ "
	^ ProductRing components: {self. aRing}
]

{ #category : #operations }
Ring >> radical [
	"Answer the Jacobson radical J(R) of the receiver R. This is the ideal consisting of all elements that annihilate all simple R-modules. It is the intersection of all maximal ideals."
	self isLocal ifTrue: [^ self maximalIdeal].
	^ self subclassResponsibility

"alternative:
	| answer |
	answer := self oneIdeal.
	self maximalIdealsDo: [:each| answer := answer ï each].
	^ answer"
]

{ #category : #operations }
Ring >> raisedTo: n [
"	n isInfinity ifTrue: [^ InfiniteTupleSpace over: self]."
	^ n isPoint ifTrue: [MatrixModule new: n over: self] ifFalse: [TupleModule new: n over: self]
]

{ #category : #enumerating }
Ring >> relevantPrimeIdealsDo: aBlock [
	self primeIdealsDo: [:each| each isRelevant ifTrue: [aBlock value: each]]
]

{ #category : #operations }
Ring >> residueField [
	"If the receiver is a local ring R with unique maximal ideal M, this returns R/M."
	^ self / self maximalIdeal
]

{ #category : #operations }
Ring >> spec [
	"Answer the spectrum of the receiver, Spec(R)."
	self isCommutative ifFalse: [^ DomainError signal: 'not a commutative ring'].
	^ AffineScheme coordinateRing: self
]

{ #category : #morphisms }
Ring >> to: aCodomain [
	(aCodomain isRing and: [self isTrivial or: [aCodomain isTrivial]])
		ifTrue: [^ self to: aCodomain evaluating: [:x| aCodomain zero]].
	^ super to: aCodomain
]

{ #category : #morphisms }
Ring >> to: aRing evaluating: aBlock [
	aRing isRing ifFalse: [^ super to: aRing evaluating: aBlock].
	^ RingMap from: self to: aRing evaluating: aBlock
]

{ #category : #'elements-tuples' }
Ring >> tuple: anArray [
	^ DenseTuple coefficients: anArray over: self
]

{ #category : #'elements-tuples' }
Ring >> tuple: anInteger constant: anElement [
	^ self tuple: anInteger evaluating: [:i| anElement]
]

{ #category : #'elements-tuples' }
Ring >> tuple: anInteger e: index [
	| zero |
	zero := self zero.
	^ self tuple: anInteger evaluating: [:i| i = index ifTrue: [self one] ifFalse: [zero]]
]

{ #category : #'elements-tuples' }
Ring >> tuple: anInteger evaluating: aBlock [
	| array |
	array := Array new: anInteger.
	1 to: anInteger do: [:i| array at: i put: (aBlock value: i)].
	^ DenseTuple coefficients: array over: self
]

{ #category : #'elements-tuples' }
Ring >> tupleClass [
	^ DenseTuple
]

{ #category : #operations }
Ring >> units [
	"Answer the multiplicative group of units of the receiver (i.e., elements that have multiplicative inverse)."
	^ UnitGroup on: self
]

{ #category : #enumerating }
Ring >> unitsDo: aBlock [
	self do: [:each| (self isUnit: each) ifTrue: [aBlock value: each]]
]

{ #category : #accessing }
Ring >> valuation [
	"Answer the Euclidean function of the receiver, if it is an Euclidean domain."
	^ self propertyAt: #valuation
]

{ #category : #operations }
Ring >> zeroDivisors [
	^ self select: [:each| self isZeroDivisor: each]
]

{ #category : #operations }
Ring >> zeroIdeal [
	^ self * #()
]

{ #category : #'elements-matrices' }
Ring >> zeroMatrix: dimension [
	^ self matrix: dimension scalar: self zero
]

{ #category : #'elements-tuples' }
Ring >> zeroTuple: anInteger [
	^ self tuple: anInteger constant: self zero
]
