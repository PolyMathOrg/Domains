"
I am the Modified (stabilized) Gram-Schmidt basis orthogonalization algorithm.

Input: a basis B = {v_1, ..., v_n} of m-tuples;
Output: another basis, namely B' = {v_1', ..., v_n'} generating the same subspace and satisfying:
	o. v_1' = v_1;
	o. v_i' is the orthogonal projection of v_i onto the space generated by the first i-1 vectors.
Furthermore, the algorithm computes a lower triangular matrix, M, such that:
	B = B'^t M.

The algorithm performs O(2mn^2) arithmetic operations.

"
Class {
	#name : #GramSchmidt,
	#superclass : #Object,
	#instVars : [
		'basis',
		'innerProduct',
		'orthogonalBasis',
		'matrix'
	],
	#category : #'Mathematics-Etc'
}

{ #category : #'instance creation' }
GramSchmidt class >> basis: aLinearBasis [
	"Answer a new instance of the receiver to orthogonalize aLinearBasis."
	^ self basis: aLinearBasis innerProduct: aLinearBasis ambient innerProduct
]

{ #category : #'instance creation' }
GramSchmidt class >> basis: aLinearBasis innerProduct: aFunction [
	"Answer a new instance of the receiver to orthogonalize aLinearBasis with the inner product aFunction."
	^ self new basis: aLinearBasis; innerProduct: aFunction
]

{ #category : #examples }
GramSchmidt class >> example [
	"Compute an orthogonal basis for {(1,1,0); {0,1,1); (1,0,1)}."
	| V basis |
	V := QQ raisedTo: 3.
	basis := LinearBasis on: V elements: {(1, 1, 0). (0, 1, 1). (1, 0, 1)}.
	^ (GramSchmidt basis: basis) orthogonalBasis
]

{ #category : #'accessing-private' }
GramSchmidt >> basis: aLinearBasis [
	basis := aLinearBasis
]

{ #category : #'accessing-private' }
GramSchmidt >> innerProduct: aFunction [
	innerProduct := aFunction
]

{ #category : #accessing }
GramSchmidt >> matrix [
	"Answer the matrix computed by the orthogonalization process."
	matrix isNil ifTrue: [matrix := basis changeTo: self orthogonalBasis].
	^ matrix
]

{ #category : #accessing }
GramSchmidt >> orthogonalBasis [
	"Answer the orthogonalized basis."
	orthogonalBasis isNil ifTrue: [self orthogonalize].
	^ orthogonalBasis
]

{ #category : #operations }
GramSchmidt >> orthogonalize [
	"Orthogonalize the basis."
	| orthogonalVectors u uv vv |
	orthogonalVectors := OrderedCollection new.
	basis do: [:each|
		u := each.
		orthogonalVectors do: [:v|
			uv := innerProduct value: {u. v}.
			vv := innerProduct value: {v. v}.
			u := u - (v * uv / vv)].
		orthogonalVectors add: u].
	orthogonalBasis := LinearBasis on: basis ambient elements: orthogonalVectors
]

{ #category : #accessing }
GramSchmidt >> orthonormalBasis [
	^ LinearBasis on: basis ambient elements: (self orthogonalBasis collect: [:each| each / (innerProduct value: each value: each) squareRoot])
]
