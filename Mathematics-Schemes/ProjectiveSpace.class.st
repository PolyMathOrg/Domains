"
Projective spaces P^nR as schemes, i.e. Proj R[x1,...,xn] for some commutative ring R.

"
Class {
	#name : #ProjectiveSpace,
	#superclass : #ProjectiveVariety,
	#category : #'Mathematics-Schemes-Projective'
}

{ #category : #'instance creation' }
ProjectiveSpace class >> coordinateRing: aPolynomialRing [
	^ (aPolynomialRing rank = 1 ifTrue: [ProjectiveLine] ifFalse: [self]) new coordinateRing: aPolynomialRing
]

{ #category : #examples }
ProjectiveSpace class >> example1 [
	"The rational projective plane:"
	^ ProjectiveSpace new: 2 over: QQ
]

{ #category : #examples }
ProjectiveSpace class >> example2 [
	"Or assigning names to the indeterminates of the homogeneous coordinate ring:"
	^ ProjectiveSpace new: #(x y z) over: QQ
]

{ #category : #examples }
ProjectiveSpace class >> example3 [
	"And equivalently:"
	^ (QQ polynomialsIn: #(x y z)) proj
]

{ #category : #'instance creation' }
ProjectiveSpace class >> new: rank over: aRing [
	^ self coordinateRing:
		(rank isInteger
			ifTrue: [aRing polynomialsIn: rank+1]
			ifFalse: [aRing polynomialsIn: rank])
]

{ #category : #accessing }
ProjectiveSpace >> ambient [
	^ self
]

{ #category : #morphisms }
ProjectiveSpace >> automorphisms [
	"Answer the group of automorphisms PGL(P), i.e. the linear automorphisms. These are the only regular automorphisms.
	Note that there are more rational automorphisms, the Cremona maps, but they are not included in this group. In the projective plane, the group of birational automorphisms is generated by the linear automorphisms plus the standard quadratic transformation (that takes each coordinate to its reciprocal xi -> 1/xi)."
	self notYetImplemented
]

{ #category : #operations }
ProjectiveSpace >> cartProd: aProjectiveSpace [ "◊ "
	"Answer the cartesian product of the receiver and the argument."
	(aProjectiveSpace isKindOf: ProjectiveSpace)
		ifFalse: [^' super ◊ aProjectiveSpace'].
	^ ProductProjectiveSpace components: {self. aProjectiveSpace}
]

{ #category : #accessing }
ProjectiveSpace >> dimension [
	^ self coordinateRing dimension - 1
]

{ #category : #accessing }
ProjectiveSpace >> gradings [
	"Answer the gradings of the coordinate ring of the receiver.
	When all the gradings are 1 this is ordinary projective space, otherwise it is a weighted (or graded) projective space."
	^ self coordinateRing gradings
]

{ #category : #accessing }
ProjectiveSpace >> ideal [
	"Answer the defining ideal of the receiver, considered as a subscheme of itself."
	^ self coordinateRing zeroIdeal
]

{ #category : #testing }
ProjectiveSpace >> isOrdinaryProjectiveSpace [
	"Answer true if the receiver is the ordinary projective space, which means that it's not weighted (or that all weights or gradings are 1)."
	^ self coordinateRing gradings allSatisfy: [:each| each = 1]
]

{ #category : #testing }
ProjectiveSpace >> isPlane [
	^ self rank = 3
]

{ #category : #private }
ProjectiveSpace >> newPatch: i [
	^ (self coordinateRing copyWithout: i) spec
]

{ #category : #points }
ProjectiveSpace >> pointsCountOver: aRing [
	aRing isField ifTrue: [^ aRing isFinite ifTrue: [^ self rank choose: 1 q: aRing size] ifFalse: [aRing size]].
	aRing isFinite ifFalse: [^ aRing size].
	(aRing isKindOf: ModularIntegerRing)
			ifTrue:
				[^ ((aRing modulus) raisedTo: (self rank - 1) )* ((aRing modulus factors asSet collect: [:p| (0 to: self rank - 1) sum: [:i| 1 / (p raisedTo: i)]]) fold: [:a :b| a*b])].
	^ super pointsCountOver: aRing
]

{ #category : #points }
ProjectiveSpace >> pointsOver: aRing do: aBlock [
	| old |
	aRing isField ifTrue: [^ self pointsOverField: aRing do: aBlock].
	(aRing isKindOf: RationalIntegerRing)
		ifTrue: [^ self pointsOverIntegersDo: aBlock].
	old := Set new.
	'aRing ^ self rank do: [:each|
			| point |
			each isZero ifFalse:
				[point := self pointAt: each.
				old add: point ifAbsent: [aBlock value: point]]]'
]

{ #category : #'points-private' }
ProjectiveSpace >> pointsOverField: aRing do: aBlock [
	| one zero |
	one := aRing one.
	zero := aRing zero.
	'aRing ^ (self rank - 1) do: [:each|
			(each isZero not and: [(each at: each lastNonZero) = one])
				ifTrue: [aBlock value: (self pointAt: each, zero)].
			aBlock value: (self pointAt: (each, one))]'.
]

{ #category : #printing }
ProjectiveSpace >> printOn: aStream [
	aStream nextPutAll: 'PP'; nextPutAll: (self rank - 1) printString; print: self scalars
]

{ #category : #morphisms }
ProjectiveSpace >> quadraticMap [
	"Answer the standard quadratic map that takes each coordinate to its reciprocal.
	This is a birational automorphism. In the projective plane, this automorphism together with the linear automorphisms of PGL generate the group of birational automorphisms."
	^ self to: self evaluating: [:x| x apply: [:each| each reciprocal]]
]

{ #category : #accessing }
ProjectiveSpace >> rank [
	^ self coordinateRing rank
]

{ #category : #testing }
ProjectiveSpace >> satisfies: aTuple [
	^ true
]

{ #category : #private }
ProjectiveSpace >> saturated [
	^ self
]

{ #category : #operations }
ProjectiveSpace >> subscheme: anObject [
	| I |
	I := (anObject isKindOf: Ideal)
		ifTrue: [anObject] ifFalse: [self coordinateRing * anObject].
	^ (self coordinateRing / I) proj
]

{ #category : #morphisms }
ProjectiveSpace >> veronese: degree [
	"Answer the Veronese map of the given degree from the receiver."
	| F monomials |
	F := self functionField.
	monomials := (F integers allMonomialsOfDegree: degree) collect: [:each| F embed: each].
	^ RationalMap from: self to: (ProjectiveSpace new: monomials size - 1 over: self scalars) representatives: monomials
]
