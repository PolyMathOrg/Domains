"
Polynomial rings R[x1,...,xn] in one or many indeterminates over a commutative ring R.

The number of indeterimnates is called the rank of the polynomial ring. The indeterminates are referred by index (positive integer numbers).

Polynomial rings have an associated monomial ordering. This is used for defining the leading term of a polynomial, multivariate division (also called normal form or reduction) and the computation of Groebner bases and standard bases.

"
Class {
	#name : #PolynomialRing,
	#superclass : #Ring,
	#instVars : [
		'monomials',
		'scalars'
	],
	#category : #'Mathematics-Polynomials'
}

{ #category : #examples }
PolynomialRing class >> example11 [
	"Creating a polynomial in Z[x]."
	| R x |
	R := ZZ polynomials.
	x := R x.
	^ (x raisedTo: 2) - x + 3
]

{ #category : #examples }
PolynomialRing class >> example12 [
	"Creating a polynomial in Z[x] from a tuple of coefficients."
	^ ZZ polynomials coefficients: #(3 -1 1)
]

{ #category : #examples }
PolynomialRing class >> example13 [
	"Creating a polynomial in Z[x] from a block."
	^ 'ZZ polynomials ! [:x| x^2 - x + 3]'
]

{ #category : #examples }
PolynomialRing class >> example21 [
	"Creating a polynomial in Q[x,y]."
	| R x y |
	R := ZZ polynomialsIn: #(x y). "these are just names for printing"
	x := R x: 1.
	y := R x: 2.
	^ (x raisedTo: 2) - (x*y) + 1
]

{ #category : #examples }
PolynomialRing class >> example22 [
	"A more compact way to create a polynomial in Q[x,y]."
	^ (ZZ polynomialsIn: #(x y)) ! [:x :y| (x raisedTo:2) - (x*y) + 1]
]

{ #category : #examples }
PolynomialRing class >> example23 [
	"Creating a polynomial in Q[x,y] with local graded lexicographic ordering."
	| R x y |
	R := ZZ polynomialsIn: #(x y) ordering: #lglex.
	x := R x: 1.
	y := R x: 2.
	^ (x raisedTo: 2) - (x*y) + 1
]

{ #category : #'instance creation' }
PolynomialRing class >> new: anInteger over: aRing [
	^ self new monomials: (FreeAbelianMonoid new: anInteger); scalars: aRing
]

{ #category : #'instance creation' }
PolynomialRing class >> new: anInteger over: aRing ordering: aMonomialOrdering [
	^ self new monomials: (FreeAbelianMonoid new: anInteger ordering: aMonomialOrdering); scalars: aRing
]

{ #category : #elements }
PolynomialRing >> ! anObject [
	| f parts |
	(anObject isKindOf: Polynomial)
		ifFalse: [ (anObject isInteger or: [ anObject isFraction ])
				ifTrue: [ ^ self constant: self scalars ! anObject ].
			(self scalars includes: anObject)
				ifTrue: [ ^ self constant: anObject ].
			anObject isEvaluable
				ifTrue: [ ^ self evaluating: anObject ].
			^ super ! anObject ].
	f := anObject.
	f parent scalars = self scalars
		ifFalse: [ f := f over: self scalars ].
	(f indeterminates allSatisfy: [ :each | each <= self rank ])
		ifFalse: [ self error: 'unknown indeterminates are present' ].
	(f isKindOf: UnivariatePolynomial)
		ifTrue: [ self isUnivariate
				ifTrue: [ ^ self coefficients: f coefficients ].
			parts := OrderedCollection new: f coefficients size.
			f coefficients
				withIndexDo: [ :coefficient :i | 
					coefficient isZero
						ifFalse: [ parts add: (monomials x: 1 to: i - 1) -> coefficient ] ] ]
		ifFalse: [ parts := f parts
				collect: [ :each | each copy key: self monomials ! each key ] ].
	parts sort.
	^ self parts: parts
]

{ #category : #operations }
PolynomialRing >> * anElementOrArray [
	"Answer the ideal generated by the argument."
	| generators |
	generators := (anElementOrArray isCollection) ifTrue: [anElementOrArray] ifFalse: [{anElementOrArray}].
	^ (self scalars isField and: [generators allSatisfy: [:each| each isMonomial]])
		ifTrue: [MonomialIdeal over: self generators: generators]
		ifFalse: [PolynomialIdeal over: self generators: generators]
]

{ #category : #comparing }
PolynomialRing >> < aDomain [
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars < aDomain scalars ifFalse: [^ false].
	^ true
]

{ #category : #comparing }
PolynomialRing >> <= aDomain [
	"Answer true if the receiver is included in the argument, i.e. it's a subring of the argument."
	self == aDomain ifTrue: [^ true].
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars <= aDomain scalars ifFalse: [^ false].
	^ true
]

{ #category : #comparing }
PolynomialRing >> = anObject [
	self == anObject ifTrue: [^ true].
	^ (anObject isKindOf: PolynomialRing) and: [self scalars = anObject scalars and: [self rank = anObject rank "and: [self ordering = anObject ordering]"]]
]

{ #category : #comparing }
PolynomialRing >> > aDomain [
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars > aDomain scalars ifFalse: [^ false].
	^ true
]

{ #category : #comparing }
PolynomialRing >> >= aDomain [
	(aDomain isKindOf: PolynomialRing) ifFalse: [^ false].
	self rank = aDomain rank ifFalse: [^ false].
	self scalars >= aDomain scalars ifFalse: [^ false].
	^ true
]

{ #category : #enumerating }
PolynomialRing >> allMonomialsOfDegree: anInteger [
	^ (self monomials allMonomialsOfDegree: anInteger) collect: [:each| self monomial: each]
]

{ #category : #converting }
PolynomialRing >> asMultivariate [
	| answer |
	self isUnivariate ifFalse: [^ self].
	answer := self scalars scalars polynomialsIn: self scalars rank + 1.
	(self names notNil and: [self scalars names notNil])
		ifTrue: [answer names: self scalars names, self names].
	^ answer
]

{ #category : #converting }
PolynomialRing >> asUnivariate [
	self isUnivariate ifTrue: [^ self].
	self names notNil
		ifTrue: [^ (self scalars polynomialsIn: self names allButLast) polynomialsIn: {self names last}].
	^ (self scalars polynomialsIn: self rank - 1) polynomials
]

{ #category : #converting }
PolynomialRing >> asUnivariateIn: anIndeterminate [
	anIndeterminate = self rank ifFalse: [^ self error: 'bad indeterminate'].
	^ self asUnivariate
]

{ #category : #random }
PolynomialRing >> atRandom: aRandom bits: bitSize [
	^ self atRandom: aRandom bits: bitSize maxDegree: ((bitSize raisedTo: (1/self rank)) min: bitSize - 1) truncated
]

{ #category : #random }
PolynomialRing >> atRandom: aRandom bits: bitSize maxDegree: d [
	| answer term n |
	self isUnivariate
		ifTrue: [^ self coefficients: ('self scalars ^ (d+1) atRandom: aRandom bits: bitSize')].
	answer := self zero.
	n := 2 raisedTo: self rank.
	n timesRepeat:
		[term := ((1 to: d) product: [:i| self x: (self rank atRandom: aRandom) to: (2 atRandom: aRandom) - 1]) * (self scalars atRandom: aRandom bits: bitSize/(self rank*d)).
		answer := answer + term].
	^ answer
]

{ #category : #random }
PolynomialRing >> atRandom: aRandom maxDegree: d [
	self isUnivariate
		ifFalse: [ ^ self notYetImplemented ].
	^ self
		coefficients:
			((self scalars raisedTo: (d+1))
				evaluating: [ :i | self scalars atRandom: aRandom ])
]

{ #category : #random }
PolynomialRing >> atRandomBits: bitSize maxDegree: d [
	^ Random withDefaultDo: [:aRandom| self atRandom: aRandom bits: bitSize maxDegree: d]
]

{ #category : #random }
PolynomialRing >> atRandomDegree: d [
	"Answer a polynomial of degree d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: ('self scalars ^ d') atRandom, self scalars one
]

{ #category : #random }
PolynomialRing >> atRandomMaxDegree: d [
	"Answer a polynomial of degree at most d choosen at random with a uniform distribution."
	self isUnivariate ifFalse: [^ self notYetImplemented].
	^ self coefficients: ('self scalars ^ (d+1)') atRandom
]

{ #category : #accessing }
PolynomialRing >> characteristic [
	^ scalars characteristic
]

{ #category : #examples }
PolynomialRing >> chebyshevOfOrder: n [
	"Answer the n-th Chebyshev polynomial."

	| answer c m k |
	n <= 0 ifTrue: [^ self one].
	c := (1 bitShift: n - 1).
	m := 4.
	k := n - 1.
	answer := self coefficient: self scalars one * c degree: n.
	n - 1 to: 1 by: -2 do: [ :each |
		c := ((c * (each + 1) * each) / (k * m)) negated.
		m := m + 4.
		k := k - 1.
		c = 0 ifFalse: [answer := answer + (self coefficient: self scalars one * c degree: each - 1)]].
	^ answer
]

{ #category : #elements }
PolynomialRing >> coefficient: aNumber degree: anInteger [
	^ self coefficients: (self scalars tuple: {aNumber}) >>> anInteger
]

{ #category : #elements }
PolynomialRing >> coefficient: aNumber monomial: aMonomial [
	^ self isUnivariate
		ifTrue:
			[| n zero coefficients |
			n := aMonomial degree + 1.
			zero := aNumber zero.
			coefficients := self scalars tuple: n evaluating: [:i| i=n ifTrue: [aNumber] ifFalse: [zero]].
			(UnivariatePolynomial coefficients: coefficients) parent: self]
		ifFalse:
			[| parts |
			parts := aNumber isZero ifTrue: [OrderedCollection new] ifFalse: [OrderedCollection with: aMonomial -> aNumber].
			(MultivariatePolynomial parts: parts) parent: self]
]

{ #category : #elements }
PolynomialRing >> coefficient: aNumber x: anIndeterminate to: anInteger [
	| i |
	i := anIndeterminate isInteger
		ifTrue: [anIndeterminate]
		ifFalse: [self names indexOf: anIndeterminate ifAbsent: [^ self error: 'unknown indeterminate']].
	^ self coefficient: aNumber monomial: (monomials x: i to: anInteger)
]

{ #category : #elements }
PolynomialRing >> coefficients: aTuple [
	| coefficients |
	self isUnivariate ifFalse: [^ self error: 'not univariate ring'].
	coefficients := aTuple class = self scalars tupleClass
		ifTrue: [aTuple]
		ifFalse: [self scalars tuple: aTuple].
	^ (UnivariatePolynomial coefficients: coefficients) parent: self
]

{ #category : #operations }
PolynomialRing >> completion [
	"Answer the ring of power series, i.e. the completion of the receiver at 0."
	^ PowerSeriesRing polynomials: self
]

{ #category : #elements }
PolynomialRing >> constant: aNumber [
	self isUnivariate ifTrue: [^ self coefficients: (self scalars tuple: {aNumber})].
	^ self coefficient: aNumber monomial: monomials identity
]

{ #category : #examples }
PolynomialRing >> continuantOfOrder: n [
	"Answer the continuant polynomial of order n."
	"(QQ polynomialsIn: #(x y z)) continuantOfOrder: 3"

	n = 0 ifTrue: [^ self one].
	n = 1 ifTrue: [^ self x: 1].
	^ (self continuantOfOrder: n - 1) * (self x: n) + (self continuantOfOrder: n - 2)
]

{ #category : #'as yet unclassified' }
PolynomialRing >> copy [
	| answer |
	answer := super copy.
	answer properties removeKey: #one ifAbsent: []; removeKey: #zero ifAbsent: [].
	^ answer
]

{ #category : #converting }
PolynomialRing >> copyWithout: anIndeterminate [
	"Answer a polynomial ring like the receiver but with one less indeterminate.
	Keep monomial ordering. Also keep indeterminate names if present."
	^ self names
		ifNil: [self scalars polynomialsIn: self rank - 1 ordering: (self ordering copyWithout: anIndeterminate)]
		ifNotNil: [:indeterminates|
			self scalars
				polynomialsIn: (indeterminates copyWithoutIndex: anIndeterminate)
				ordering: (self ordering copyWithout: anIndeterminate)]
]

{ #category : #examples }
PolynomialRing >> cyclicIdeal [
	"Answer the ideal of cyclic n-roots, used for benchmarks."
	| generators |
	generators := OrderedCollection new.
	0 to: self rank - 2 do: [ :j | 
		| g |
		g := (1 to: self rank)
			sum: [ :i | 
				((i to: i + j) collect: [ :k | self x: (k - 1) \\ self rank + 1 ])
					fold: [ :a :b | a * b ] ].
		generators add: g ].
	generators add: (self generators fold: [ :a :b| a*b]) - 1.
	^ self * generators
]

{ #category : #examples }
PolynomialRing >> cyclotomic: n [
	"Answer the n-th cyclotomic polynomial."

	| one x answer	"numerator denominator" product |
	one := self one.
	x := self x.
	n = 1
		ifTrue: [ ^ x - one ].
	n isPrime
		ifTrue: [ answer := one.
			n - 1 timesRepeat: [ answer := answer * x + one ].
			^ answer ].
	"	numerator := one.
	denominator := one.
	n divisorsDo: [:d| | mu |
		mu := (n/d) moebius.
		mu = 1 ifTrue: [numerator := numerator * (x^d - one)].
		mu = -1 ifTrue: [denominator := denominator * (x^d - one)]].
	^ numerator // denominator"
	product := self one.
	n divisors
		do: [ :each | 
			each = n
				ifFalse: [ product := product * (self cyclotomic: each) ] ].
	^ ((x raisedTo: n) - one) // product
]

{ #category : #examples }
PolynomialRing >> determinantOfOrder: n [
	"Answer the determinant polynomial of order n."
	"QQ polynomials determinantOfOrder: 3"

	n = 0 ifTrue: [^ self zero].
	^ '(self ^ (n@n) evaluating: [:i :j| self x: n * (j - 1) + i]) determinant'
]

{ #category : #accessing }
PolynomialRing >> dimension [
	"Answer the Krull dimension of the receiver."
	self isLocal ifTrue: [^ -1].
	self isGlobal ifFalse: [^ self error: 'not a global ring'].
	self scalars isNoetherian ifTrue: [^ self scalars dimension + self rank].
	^ super dimension
]

{ #category : #enumerating }
PolynomialRing >> do: aBlock [
	| k |
	self scalars isFinite ifFalse: [^ self notYetImplemented].
	self isUnivariate ifFalse: [^ self notYetImplemented].
	aBlock value: self zero.
	k := 1.
	[(self scalars raisedTo: k) do: [:t| t last isZero ifFalse: [aBlock value: (self coefficients: t)]].
	k := k + 1] repeat
]

{ #category : #morphisms }
PolynomialRing >> embed: aScalar [
	^ self constant: aScalar
]

{ #category : #morphisms }
PolynomialRing >> embedding [
	"Answer the embedding map from the base ring into the receiver."
	^ self propertyAt: #embedding ifAbsentPut: [(self scalars to: self evaluating: [:x| self constant: x]) name: 'i']
]

{ #category : #elements }
PolynomialRing >> evaluating: aBlock [
	^ aBlock valueWithArguments: self generators
]

{ #category : #examples }
PolynomialRing >> fibonacciOfOrder: n [
	"Answer the n-th Fibonacci polynomial."
	"QQ polynomials fibonacciOfOrder: 3"

	n negative ifTrue: [^ self notYetImplemented].
	n = 0 ifTrue: [^ self zero].
	n = 1 ifTrue: [^ self one].
	^ (self fibonacciOfOrder: n - 1) - (self x * (self fibonacciOfOrder: n - 2))
]

{ #category : #operations }
PolynomialRing >> filtrationAt: anInteger [
	"Answer the submodule of polynomials of degree <= anInteger."
	^ PolynomialFiltrationModule new polynomials: self; degree: anInteger
]

{ #category : #elements }
PolynomialRing >> findIrreducibleOfDegree: n [
	| one x p random |
	one := self scalars one.
	x := self x.
	1 to: n-1 do: [:k|
		p := (x raisedTo: n) + (x raisedTo: k) + one.
		p isIrreducible ifTrue: [^ p]].
	"self error: 'irreducible polynomial not found'"
	random := Random new.
	[(p := self atRandom: random maxDegree: n) degree = n and: [p isIrreducible]] whileFalse.
	^ p
]

{ #category : #operations }
PolynomialRing >> fractions [
	"Answer the field of rational functions, i.e. the localization of the receiver at 0."
	^ self propertyAt: #fractions ifAbsentPut:
		[self scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
		RationalFunctionField on: self]
]

{ #category : #morphisms }
PolynomialRing >> from: aDomain [
	aDomain = self scalars ifTrue: [^ self embedding].
	'aDomain  self scalars ifNotNil: [:aMorphism| ^ self embedding î aMorphism]'.
	((aDomain isKindOf: PolynomialRing) and: [aDomain rank = self rank])
		ifTrue: ['aDomain scalars ' self scalars ifNotNil: [:aMorphism| ^ aDomain to: self evaluating: [:f| f apply: aMorphism]]].
	^ super from: aDomain
]

{ #category : #accessing }
PolynomialRing >> generators [
	^ (1 to: self rank) collect: [:i| self x: i]
]

{ #category : #operations }
PolynomialRing >> gradingAt: anInteger [
	"Answer the submodule of homogeneous polynomials of degree anInteger."
	^ PolynomialGradingModule new polynomials: self; degree: anInteger
]

{ #category : #accessing }
PolynomialRing >> gradings [
	"Answer the degrees of the indeterminates of the receiver."
	^ (1 to: self rank) collect: [:i| 1]
]

{ #category : #testing }
PolynomialRing >> has: anIndeterminate [
	^ self indeterminates includes: anIndeterminate
]

{ #category : #comparing }
PolynomialRing >> hash [
	^ self scalars hash + self rank
]

{ #category : #operations }
PolynomialRing >> hilbertSeries [
	^ self hilbertSeriesAt: (QQ polynomialsIn: #(t)) fractions x
]

{ #category : #operations }
PolynomialRing >> hilbertSeriesAt: t [
	^ '(self gradings product: [:d| 1 - (t ^ d)]) reciprocal'
]

{ #category : #private }
PolynomialRing >> idealClass [
	^ PolynomialIdeal
]

{ #category : #testing }
PolynomialRing >> includes: anObject [
	^ (anObject isKindOf: Polynomial) and: [anObject parent <= self]
]

{ #category : #accessing }
PolynomialRing >> indeterminate [
	"Answer the univariate indeterminate."
	^ 1
]

{ #category : #accessing }
PolynomialRing >> indeterminates [
	^ 1 to: self rank
]

{ #category : #elements }
PolynomialRing >> interpolate: aCollection [
	"Answer a polynomial f that for each pair k -> v of the argument evaluates to f(k) = v.
	(Lagrange polynomials.)"
	| answer x |
	self isUnivariate ifFalse: [^ self error: 'not yet implemented'].
	x := self x.
	answer := self zero.
	aCollection do: [:a| | p |
		p := self one.
		aCollection do: [:b|
			a ~~ b ifTrue: [p := p * ((x - b key) / (a key - b key))]].
		answer := p * a value + answer].
	^ answer
]

{ #category : #testing }
PolynomialRing >> isCommutative [
	^ true
]

{ #category : #testing }
PolynomialRing >> isEuclidean [
	"Answer true if the receiver is an Euclidean ring, i.e. it has division with remainder."
	^ self scalars isEuclidean
]

{ #category : #testing }
PolynomialRing >> isGCDDomain [
	^ self scalars isField or: [self scalars isUFD]
]

{ #category : #testing }
PolynomialRing >> isGlobal [
	"Answer true if this polynomial ring is global, i.e. it uses a global monomial ordering."
	^ self ordering isGlobal
]

{ #category : #testing }
PolynomialRing >> isGraded [
	"Answer true if this polynomial ring is graded, i.e. it uses a graded monomial ordering."
	^ self ordering isGraded
]

{ #category : #testing }
PolynomialRing >> isIntegralDomain [
	^ self scalars isIntegralDomain
]

{ #category : #testing }
PolynomialRing >> isLocal [
	"Answer true if this polynomial ring is local, i.e. it uses a local monomial ordering."
	^ self ordering isLocal
]

{ #category : #testing }
PolynomialRing >> isMultivariate [
	^ self rank > 1
]

{ #category : #testing }
PolynomialRing >> isNoetherian [
	self scalars isNoetherian ifTrue: [^ true]. "Hilber's basis theorem"
	^ super isNoetherian
]

{ #category : #testing }
PolynomialRing >> isPID [
	"Univariate polynomials over a field are principal ideal domains."
	^ self scalars isField and: [self isUnivariate]
]

{ #category : #testing }
PolynomialRing >> isUFD [
	self scalars isUFD ifTrue: [^ true]. "proof based on Gauss lemma"
	^ super isUFD
]

{ #category : #testing }
PolynomialRing >> isUnit: aPolynomial [
	"Answer true if the argument is invertible."
	aPolynomial isConstant ifTrue: [^ self scalars isUnit: aPolynomial leadingCoefficient].
	self scalars isIntegralDomain ifTrue: [^ false].
	((self scalars isKindOf: GaloisRing) or: [self scalars isKindOf: PrimeRing])
		ifTrue:
			[| M a |
			M := self scalars maximalIdeal.
			a := aPolynomial coefficients.
			(M contains: (a at: 1)) ifTrue: [^ false].
			2 to: a size do: [:i| (M contains: (a at: i)) ifFalse: [^ false]].
			^ true].
	^ self notYetImplemented
]

{ #category : #testing }
PolynomialRing >> isUnivariate [
	^ self rank = 1
]

{ #category : #examples }
PolynomialRing >> katsuraIdeal [
	"Answer the Katsura ideal, used for benchmarks."
	| n f generators |
	n := self rank.
	generators := OrderedCollection new.
	f := self ! -1.
	1-n to: n-1 do: [:i| f := (self x: i abs + 1) + f].
	generators add: f.
	0 to: n-2 do: [:i|
		f := (self x: i+1) * -1.
		1-n to: n-1 do: [:j| | k |
			k := (i-j) abs + 1.
			k <= n ifTrue: [f := (self x: j abs + 1) * (self x: k) + f]].
		generators add: f].
	^ self * generators
]

{ #category : #operations }
PolynomialRing >> localization [
	"Answer the localization of the receiver at <x1,...,xn>. This is achieved by choosing a local ordering.
	Objects defined in this localization contain geometric information (usually only) about a Zariski neighbourhood of 0 in K^n, while objects in the global ring contain geometric information whish is valid in the whole affine space K^n."
	self isGlobal ifFalse: [DomainError signal: 'the ring is not global'].
	^ self orderedBy: #lglex
]

{ #category : #accessing }
PolynomialRing >> maximalIdeal [
	"If the receiver is a local ring, answer the unique maximal ideal."
	self isLocal ifFalse: [DomainError signal: 'the ring is not local'].
	^ self * self generators
]

{ #category : #elements }
PolynomialRing >> monomial: aMonomial [
	^ self coefficient: self scalars one monomial: aMonomial
]

{ #category : #accessing }
PolynomialRing >> monomials [
	"Answer the monoid of monomials of the receiver."
	^ monomials
]

{ #category : #'accessing-private' }
PolynomialRing >> monomials: aFreeAbelianMonoid [
	monomials := aFreeAbelianMonoid
]

{ #category : #accessing }
PolynomialRing >> names [
	"Answer the indeterminate names to use when printing polynomials."
	^ monomials names
]

{ #category : #accessing }
PolynomialRing >> names: aCollection [
	"Set indeterminate names to use when printing polynomials."
	monomials names: aCollection
]

{ #category : #elements }
PolynomialRing >> one [
	^ self propertyAt: #one ifAbsentPut: [self constant: self scalars one]
]

{ #category : #converting }
PolynomialRing >> orderedBy: aMonomialOrdering [
	^ self copy monomials: (self monomials orderedBy: aMonomialOrdering)
]

{ #category : #accessing }
PolynomialRing >> ordering [
	^ monomials ordering
]

{ #category : #'accessing-private' }
PolynomialRing >> ordering: aMonomialOrdering [
	monomials ordering: aMonomialOrdering
]

{ #category : #converting }
PolynomialRing >> over: aRing [
	^ self copy scalars: aRing
]

{ #category : #elements }
PolynomialRing >> parts: aCollection [
	self isUnivariate
		ifTrue:
			[| n coefficients |
			n := 0.
			aCollection do: [:each| n := n max: each key degree].
			coefficients := self scalars zeroTuple: n+1.
			aCollection do: [:each| coefficients at: each key degree + 1 put: each value].
			^ self coefficients: coefficients].
	^ (MultivariatePolynomial parts: aCollection) parent: self
]

{ #category : #printing }
PolynomialRing >> printIndeterminatesOn: aStream [
	self ordering indeterminates
		do: [:i| aStream print: (self x: i)]
		separatedBy: [aStream nextPut: $,]
]

{ #category : #printing }
PolynomialRing >> printOn: aStream [
	aStream print: self scalars; nextPut: $[.
	self printIndeterminatesOn: aStream.
	aStream nextPut: $].
	self ordering isLocal ifTrue: [aStream nextPutAll: self maximalIdeal printText sub]
]

{ #category : #operations }
PolynomialRing >> proj [
	"Answer the projective space associated to the receiver, Proj(R)."
	^ ProjectiveSpace coordinateRing: self
]

{ #category : #operations }
PolynomialRing >> raisedTo: n [
	(n isInteger and: [self isMultivariate]) ifFalse: [^ 'super ^ n'].
	^ MultivariateTupleModule new: n over: self
]

{ #category : #accessing }
PolynomialRing >> rank [
	"The rank of a polynomial ring is the number of indeterminates. Univariate polynomials have rank 1."
	^ monomials rank
]

{ #category : #accessing }
PolynomialRing >> scalars [
	^ scalars
]

{ #category : #'accessing-private' }
PolynomialRing >> scalars: aRing [
	scalars := aRing
]

{ #category : #accessing }
PolynomialRing >> size [
	^ Aleph new * self scalars size
]

{ #category : #operations }
PolynomialRing >> spec [
	"Answer the spectrum of the receiver, Spec(R)."
	^ AffineSpace coordinateRing: self
]

{ #category : #examples }
PolynomialRing >> symmetric: r [
	"Answer the r-th symmetric polynomial whose terms are all monomials formed by the product of r distinct indeterminates."
	| answer |
	answer := self zero.
	(1 to: self rank) combinations: r atATimeDo: [:each| answer := answer + (each product: [:i| self x: i])].
	^ answer
]

{ #category : #morphisms }
PolynomialRing >> to: aRing evaluating: aBlock [
	(aRing isKindOf: PolynomialRing) ifFalse: [^ super to: aRing evaluating: aBlock].
	^ PolynomialRingMap from: self to: aRing evaluating: aBlock
]

{ #category : #accessing }
PolynomialRing >> valuation [
	"Answer the Euclidean function of the receiver, if it is an Euclidean domain."
	^ self scalars isField ifTrue: [Function from: self to: NN evaluating: [:f| f degree]]
]

{ #category : #elements }
PolynomialRing >> x [
	^ self x: self indeterminates first
]

{ #category : #elements }
PolynomialRing >> x: anIndeterminate [
	^ self x: anIndeterminate to: 1
]

{ #category : #elements }
PolynomialRing >> x: anIndeterminate to: n [
	^ self coefficient: self scalars one x: anIndeterminate to: n
]

{ #category : #elements }
PolynomialRing >> xTo: degree [
	^ self x: self indeterminate to: degree
]

{ #category : #elements }
PolynomialRing >> y [
	^ self x: self indeterminates second
]

{ #category : #elements }
PolynomialRing >> z [
	^ self x: self indeterminates third
]

{ #category : #elements }
PolynomialRing >> zero [
	^ self propertyAt: #zero ifAbsentPut: [self constant: self scalars zero]
]

{ #category : #comparing }
PolynomialRing >> ~ aPolynomialRing [
	"Answer true if the receiver is canonically isomorphic to the argument."
	"R[x][y] ~ R[x,y]"
	self notYetImplemented
]

{ #category : #operations }
PolynomialRing >> í [ aRing
	"Answer the tensor product of the receiver and the argument.
	This is implemented for the special case of the argument being another polynomial ring over the same coefficients ring."
	| answer |
	aRing = self scalars ifTrue: [^ self í aRing polynomials].
	((aRing isKindOf: PolynomialRing) and: [aRing scalars = self scalars])
		ifFalse: [^ self notYetImplemented].
	answer := self scalars polynomialsIn: self rank + aRing rank "ordering: self ordering, aRing ordering".
	(self names notNil and: [aRing names notNil])
		ifTrue:
			[| names xi |
			names := self names asOrderedCollection.
			aRing names do: [:each|
				xi := each.
				[names includes: xi] whileTrue: [xi := xi, ''''].
				names add: xi].
			answer names: names].
	^ answer
]
