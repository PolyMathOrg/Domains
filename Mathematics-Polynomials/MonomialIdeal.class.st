"
Polynomial ideals generated by monomials.

With monomial ideals computations are much easier than with general polynomial ideals, and in many cases problems in general polynomial ideals can be reduced to problems in simpler monomial ideals (for example, by using Groebner bases).

Monomial ideals have a rich theory with connections to convex geometry and combinatorics. There's a one-to-one correspondences between:
- Simplicial complexes on {1,2,...,n};
- Squarefree monomial ideals in K[x1,...,xn];
- Unions of coordinate subspaces of K^n.

See also SimplicialComplex.
"
Class {
	#name : #MonomialIdeal,
	#superclass : #PolynomialIdeal,
	#category : #'Mathematics-Polynomials'
}

{ #category : #operations }
MonomialIdeal >> asSimplicialComplex [
	"Answer the Stanley-Reisner simplicial complex associated to the receiver.
	This is the simplicial complex formed by the support of all squarefree monomials not in this ideal.
	Fail if this ideal is not squarefree."
	self isSquareFree ifFalse: [^ self error: 'not squarefree'].
	^ (SimplicialComplex on: self scalars indeterminates facets: (self generatingMonomials collect: [:each| each indeterminates])) complement dual
]

{ #category : #operations }
MonomialIdeal >> dual [
	"Answer the Alexander dual of the receiver.
	If I is the Stanley-Reisner ideal of a simplicial complex S, the Alexander dual of I is defined as the Stanley-Reisner ideal of the dual of S."
	^ self asSimplicialComplex dual stanleyReisnerIdealIn: self scalars
]

{ #category : #accessing }
MonomialIdeal >> generatingMonomials [
	"Answer the set of monomials corresponding to the polynomials that generate the receiver."
	^ self generators collect: [:each| each monomials anyOne]
]

{ #category : #'accessing-private' }
MonomialIdeal >> generators: aCollection [
	| generators |
	generators := Set new.
	(aCollection asSortedCollection: [:a :b| a degree <= b degree])
		do: [:each| | f |
			f := each monic.
			"make sure the generating set is minimal (and thus unique):"
			(generators anySatisfy: [:any| any | f]) ifFalse: [generators add: f]].
	super generators: generators
]

{ #category : #operations }
MonomialIdeal >> hilbertSeriesAt: t [
	"Answer the Hilbert series of the receiver."
	| n m J int |
	self isZero ifTrue: [^ t zero].
	n := self scalars rank.
	m := self generators asArray last.
	J := self class over: self scalars generators: (self generators copyWithout: m).
	int := self class over: self scalars generators: (J generators collect: [:each| each lcm: m]).
	^ 't ^ m degree / ((1 to: n) product: [:i| 1 - (t ^ (self scalars gradings at: i))])
			+ (J hilbertSeriesAt: t)
			- (int hilbertSeriesAt: t)'
]

{ #category : #testing }
MonomialIdeal >> isIrreducible [
	"Irreducible monomial ideals are those generated by powers of some of the variables."
	^ self generatingMonomials allSatisfy: [:each| each support size = 1]
]

{ #category : #testing }
MonomialIdeal >> isPrimary [
	"Primary monomial ideals are those containing powers of each of a certain subset of the variables, and generated by elements involving no further variables."
	^ self notYetImplemented
]

{ #category : #testing }
MonomialIdeal >> isPrime [
	"Prime monomial ideals are those generated by subsets of the variables."
	^ self generatingMonomials allSatisfy: [:each| each degree = 1 and: [each support size = 1]]
]

{ #category : #testing }
MonomialIdeal >> isRadical [
	^ self isSquareFree
]

{ #category : #testing }
MonomialIdeal >> isSquareFree [
	"A monomial ideal is squarefree iff each generator in the minimal generating set is squarefree."
	^ self generators allSatisfy: [:each| each isSquareFree]
]

{ #category : #operations }
MonomialIdeal >> polarization [
	"Answer the polarization of the receiver.
	The polarization is a deformation that assigns to an arbitrary monomial ideal a squarefree monomial ideal in a new set of variables."
	self notYetImplemented	
]

{ #category : #operations }
MonomialIdeal >> primaryDecomposition [
	"Answer the standard primary decomposition of the receiver.
	This is the unique primary decomposition obtained from an irredundant intersection of irreducible ideals."
	self isSquareFree ifFalse: [^ super primaryDecomposition].
	^ self asSimplicialComplex facets collect: [:each|
		self scalars * (self scalars indeterminates \ each vertices collect: [:i| self scalars x: i])]
]

{ #category : #printing }
MonomialIdeal >> printStaircase [
	| w h matrix |
	w := self generators max: [:each| (each degreeIn: 1) + 1].
	h := self generators max: [:each| (each degreeIn: 2) + 1].
	matrix := (1 to: h) collect: [:x| (1 to: w) collect: [:y| ' ']].
	self basis do: [:each| | x y |
		x := each degreeIn: 1.
		y := each degreeIn: 2.
		(matrix at: h-y) at: x+1 put: 'X'].
	^ String streamContents: [:aStream| matrix do: [:line| line do: [:dot| aStream nextPutAll: dot]] separatedBy: [aStream lf]]
]

{ #category : #operations }
MonomialIdeal >> quot:anIdeal [
	"Answer the colon quotient I:J of the receiver I with the argument J.
	This is defined as I:J := {r in R | rJ <= I}.
	J. Herzog, 'Monomial Ideals', Proposition 1.2.2."
	| R answer |
	(anIdeal isKindOf: MonomialIdeal)
		ifFalse: [^ 'super ˜ anIdeal'].
	R := self scalars.
	R isIntegralDomain ifFalse: [^ self error: 'not over an integral domain']. "is this needed?"
	answer := R asIdeal. "<1>"
	anIdeal generators do: [:g|
		answer := answer dot: (self class over: R generators: (self generators collect: [:each| each /// (each gcd: g)]))].
	^ answer
]

{ #category : #operations }
MonomialIdeal >> radical [
	"J. Herzog, 'Monomial Ideals', Proposition 1.2.4."
	^ self squareFree
]

{ #category : #private }
MonomialIdeal >> species [
	^ PolynomialIdeal
]

{ #category : #operations }
MonomialIdeal >> ï [ anIdeal
	"Answer the intersection of the receiver and the argument."
	"J. Herzog, 'Monomial Ideals', Proposition 1.2.1."
	| intersection |
	(anIdeal isKindOf: MonomialIdeal)
		ifFalse: [^ super dot: anIdeal].
	self scalars = anIdeal scalars ifFalse: [self error: 'rings don''t match'].
	intersection := Set new.
	self generators do: [:each|
		anIdeal generators do: [:other| intersection add: (each lcm: other)]].
	^ self class over: self scalars generators: intersection
]
