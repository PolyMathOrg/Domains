"
Polynomials in one or many indeterminates, with coefficients in a commutative ring. See PolynomialRing.

This is an abstract class. See subclasses MultivariatePolynomial and UnivariatePolynomial for concrete implementations.
"
Class {
	#name : #Polynomial,
	#superclass : #Object,
	#instVars : [
		'parent'
	],
	#category : #'Mathematics-Polynomials'
}

{ #category : #'instance creation' }
Polynomial class >> new [
	^ self shouldNotImplement
]

{ #category : #arithmetic }
Polynomial >> % anInteger [
	^ self apply: (self scalars integers % anInteger) projection
]

{ #category : #arithmetic }
Polynomial >> * anObject [
	(anObject isInteger or: [self scalars includes: anObject])
		ifTrue: [^ self multipliedByScalar: anObject].
	(self parent includes: anObject)
		ifTrue: [^ self multipliedByPolynomial: anObject].
	(anObject isKindOf: Monomial)
		ifTrue: [^ self multipliedByMonomial: anObject].
	((anObject isKindOf: Polynomial) and: [anObject scalars includes: self])
		ifTrue: [^ anObject multipliedByScalar: self].
	(anObject isKindOf: RationalFunction)
		ifTrue: [^ anObject * self].
	^ self multipliedByPolynomial: (self parent ! anObject)
]

{ #category : #arithmetic }
Polynomial >> - anObject [
	^ self + anObject negated
]

{ #category : #arithmetic }
Polynomial >> / anObject [
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self parent includes: anObject)
		ifTrue: [^ RationalFunction numerator: self denominator: anObject].
	(self scalars includes: anObject) "assumes the content is divisible by anObject"
		ifTrue: [^ self dividedByScalar: anObject].
	^ self * anObject reciprocal
]

{ #category : #arithmetic }
Polynomial >> // anObject [
	"Answer the quotient of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each // anObject]].
	^ (self divisionBy: anObject) quotient
]

{ #category : #arithmetic }
Polynomial >> /// anObject [
	"Answer the exact quotient of the division of the receiver by the argument."
	(anObject isKindOf: Monomial)
		ifTrue: [^ self dividedByMonomial: anObject].
	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each /// anObject]].
	^ self exactlyDividedBy: anObject
]

{ #category : #arithmetic }
Polynomial >> \\ anObject [
	"Answer the remainder of the division of the receiver by the argument."

	(self scalars includes: anObject)
		ifTrue: [^ self apply: [:each| each \\ anObject]].
	^ (self divisionBy: anObject) remainder
]

{ #category : #converting }
Polynomial >> adaptToComplex: rcvr andSend: selector [
	"If I am involved in arithmetic with a number, convert it to a Polynomial."
	^ (self parent constant: rcvr) perform: selector with: self
]

{ #category : #converting }
Polynomial >> adaptToNumber: rcvr andSend: selector [
	"If I am involved in arithmetic with a Number, convert it to a Polynomial."
	^ (self parent constant: rcvr) perform: selector with: self
]

{ #category : #converting }
Polynomial >> asBilinearForm [
	(self degree = 2 and: [self isHomogeneous]) ifFalse: [^ self error: 'not homogeneous of degree 2'].
	self parent rank even ifFalse: [^ self error: 'not even rank'].
	^ 'BilinearForm fromHalf: (self scalars ^ (self parent rank / 2)) evaluating: [:each| self value: each first, each second]'
]

{ #category : #converting }
Polynomial >> asIdeal [
	"Answer the ideal generated by the receiver."
	^ self parent * self
]

{ #category : #converting }
Polynomial >> asLinearForm [
	self isLinear ifFalse: [^ DomainError signal: 'not a linear polynomial'].
	^' (self scalars ^ self parent rank) dual evaluating: self'
]

{ #category : #converting }
Polynomial >> asMultivariate [
	"Convert a polynomial in R[x][y][z] to a polynomial in R[x,y,z]."
	| R S answer |
	((R := self scalars) isKindOf: PolynomialRing) ifFalse: [^ self].
	self parent isUnivariate ifFalse: [^ self].
	S := self parent asMultivariate.
	answer := S zero.
	self partsDo: [:each|
		answer := answer + (S ! each value * (S x: R rank + 1 to: each key degree))].
	^ answer
]

{ #category : #converting }
Polynomial >> asScalar [
	self isConstant ifFalse: [^ self error: 'not a constant polynomial'].
	^ self leadingCoefficient
]

{ #category : #converting }
Polynomial >> asUnivariate [
	"Answer the receiver as univariate in the last indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	| S term n d coefficients |
	self parent isUnivariate ifTrue: [^ self].
	n := self parent rank.
	S := self parent asUnivariate.
	(d := self degreeIn: n) <= 0
		ifTrue: [^ S constant: S scalars ! self].
	coefficients := Array new: d+1.
	coefficients atAllPut: S scalars zero.
	self partsDo: [:each|
		term := S scalars coefficient: each value monomial: S scalars monomials ! (each key without: n).
		coefficients at: (each key degreeIn: n)+1 add: term].
	^ S coefficients: coefficients
]

{ #category : #converting }
Polynomial >> asUnivariateIn: anIndeterminate [
	"Answer the receiver as univariate in the given indeterminate, e.g. go from R[x,y,z] to R[x,y][z]."
	(self parent isUnivariate and: [self parent indeterminate = anIndeterminate]) ifTrue: [^ self].
	anIndeterminate = self parent rank ifFalse: [self error: 'bad indeterminate'].
	^ self asUnivariate
]

{ #category : #'accessing indeterminates' }
Polynomial >> classIndeterminate [
	"Answer the 'class' of the polynomial, i.e. the index of the last indeterminate present in the receiver."
	self flag: #fix. "same as leadingIndeterminate?"
	self parent rank to: 1 by: -1 do: [:i| (self has: i) ifTrue: [^ i]].
	^ 0
]

{ #category : #'accessing coefficients' }
Polynomial >> coefficientAtDegree: anInteger [
	"Answer the coefficient of the degree given by the argument. For univiariate polynomials."
	^ self coefficientAt: (self parent monomials x: self leadingIndeterminate to: anInteger)
]

{ #category : #'accessing coefficients' }
Polynomial >> coefficients [
	"Answer the collection of non-zero coefficients of this polynomial (with repetitions)."
	^ Iterator on: self performing: #coefficientsDo:
]

{ #category : #factorization }
Polynomial >> content [
	"Answer the GCD of the coefficients of the receiver.
	In a field, it is convenient to define the content as 1.
	For example, 2x^2 + 4 has content 2 in Z[x] and 1 in Q[x]."
	| answer |
	self isZero ifTrue: [^ self scalars zero].
	self scalars isField
		ifTrue:
			[^ self scalars isFractionRing
				ifTrue:
					[| c |
					c := self coefficients inject: self scalars one into: [:lcm :each| lcm lcm: each denominator].
					(self coefficients inject: self scalars zero into: [:gcd :each| gcd gcd: each * c]) / c]
				ifFalse: [self scalars one]].
	answer := self scalars zero.
	self coefficients do: [:each| answer := answer gcd: each].
	^ answer
]

{ #category : #'accessing monomials' }
Polynomial >> degree [
	"Answer the total degree of the receiver, i.e. the maximum of the degree of its monomials."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degree]
]

{ #category : #'accessing monomials' }
Polynomial >> degreeIn: anIndeterminate [
	"Answer the degree of the receiver in the given indeterminate."
	self isZero ifTrue: [^ Infinity negative].
	^ self monomials max: [:each| each degreeIn: anIndeterminate]
]

{ #category : #operations }
Polynomial >> dehomogenizedIn: anIndeterminate [
	"Answer the dehomogenization of the receiver in the given indeterminate."
	^ self monomialsApply: [:each| each dehomogenizedIn: anIndeterminate]
]

{ #category : #accessing }
Polynomial >> denominator [
	"Considering the receiver as an element of the fraction ring, answer the denominator."
	^ self one
]

{ #category : #'accessing monomials' }
Polynomial >> density [
	"Answer a measure of the density/sparsity of the receiver."
	self isZero ifTrue: [^ 0].
	^ self coefficients size / (self degree + 1)
]

{ #category : #operations }
Polynomial >> derivative: n in: anIndeterminate [
	"Answer the n-th derivative in the given indeterminate."
	| answer |
	n < 0 ifTrue: [^ self error: 'the order of the derivative should be positive'].
	answer := self.
	n timesRepeat: [answer := answer derivativeIn: anIndeterminate].
	^ answer
]

{ #category : #operations }
Polynomial >> derivativeIn: anIndeterminate [
	| answer |
	answer := self parent zero.
	self partsDo: [:each| | degree |
		degree := each key degreeIn: anIndeterminate.
		degree > 0
			ifTrue:
				[answer := answer + (self parent coefficient: each value * degree monomial: (each key parent exponents: (each key exponents copy at: anIndeterminate put: degree - 1; yourself)))]].
	^ answer
]

{ #category : #arithmetic }
Polynomial >> divisionBy: aPolynomial [
	"Answer a division algorithm to divide the receiver by aPolynomial."
	aPolynomial isCollection ifTrue: [^ MultivariatePolynomialDivision divide: self by: aPolynomial].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ MultivariatePolynomialDivision divide: self by: {aPolynomial}].
	(aPolynomial isMonic or: [self scalars isField])
		ifFalse: [^ self pseudoDivisionBy: aPolynomial].
	^ PolynomialDivision divide: self by: aPolynomial
]

{ #category : #'accessing monomials' }
Polynomial >> ecart [
	^ self degree - self leadingMonomial degree
]

{ #category : #'remainder sequences' }
Polynomial >> eprs: aPolynomial [
	"Answer the (Pseudo) Euclidean Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer := OrderedCollection new.
	f1 := self.
	answer add: f1.
	r := aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 := f1.
			f1 := r.
			r := f0 pseudoRem: f1].
	^ answer
]

{ #category : #arithmetic }
Polynomial >> exactlyDividedBy: aPolynomial [
	"Answer the exact division of the receiver by the argument."

	self isZero
		ifTrue: [^ self].
	aPolynomial isConstant
		ifTrue: [^ self dividedByScalar: aPolynomial leadingCoefficient].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: [^ (MultivariatePolynomialDivision divide: self by: {aPolynomial}) exactQuotient].
	(aPolynomial isMonic or: [self scalars isField])
		ifFalse: [^ (PolynomialPseudoDivision divide: self by: aPolynomial) exactQuotient].
	^ (PolynomialDivision divide: self by: aPolynomial) exactQuotient
]

{ #category : #'accessing terms' }
Polynomial >> formAt: anInteger [
	"Answer the homogeneous component of degree anInteger (an anInteger-form)."
	| answer |
	answer := self zero.
	self terms do: [:each| each degree = anInteger ifTrue: [answer := answer + each]].
	^ answer
]

{ #category : #arithmetic }
Polynomial >> gcd: aPolynomial [
	"Answer the greatest common divisor of the receiver and aPolynomial."
	| a b r |
	self isZero ifTrue: [^ aPolynomial].
	aPolynomial isZero ifTrue: [^ self].
	(self isUnivariate and: [aPolynomial isUnivariate])
		ifFalse: "Multivariate case:"
			[self scalars isUFD ifFalse: [^ DomainError signal: 'not an UFD'].
			(self isConstant or: [aPolynomial isConstant])
				ifTrue: [^ self scalars isField ifTrue: [self one] ifFalse: [self parent constant: (self content gcd: aPolynomial content)]].
			a := self asUnivariate.
			b := aPolynomial asUnivariate.
			^ (self parent ! ((a primitive gcd: b primitive) * (a content gcd: b content)) asMultivariate) primitive].
	self scalars isField
		ifFalse: "If it's not a field we use the primitive PRS algorithm:"
			[a := self primitive.
			b := aPolynomial primitive.
			[b isZero] whileFalse: [r := (a pseudoRem: b) primitive. a := b. b := r].
			a isConstant ifTrue: [a := self one].
			^ a * (self content gcd: aPolynomial content)].
	a := self.
	b := aPolynomial.
	[(r := a \\ b) isZero] whileFalse: [a := b. b := r].
	^ b * b leadingCoefficient reciprocal
]

{ #category : #operations }
Polynomial >> gradient [
	^ self parent indeterminates collect: [:each| self derivativeIn: each]
]

{ #category : #'accessing indeterminates' }
Polynomial >> has: anIndeterminate [
	"Answer true if anIndeterminate is effectively present in the receiver."
	^ self monomials anySatisfy: [:any| any has: anIndeterminate]
]

{ #category : #operations }
Polynomial >> height [
	self isZero ifTrue: [^ 1].
	^ self coefficients inject: 1 into: [:x :each| x max: each height]
]

{ #category : #operations }
Polynomial >> hessian [
	"Answer the Hessian matrix of the receiver."
	self flag: #fix. "optimize"
	^ self parent matrix: self parent rank evaluating: [:i :j| (self derivativeIn: i) derivativeIn: j]
]

{ #category : #operations }
Polynomial >> homogenized [
	"Answer the homogenization of the receiver introducing a new indeterminate."
	| R S |
	R := self parent.
	S := R scalars polynomialsIn: R rank + 1.
	^ S ! self homogenizedIn: S rank
]

{ #category : #operations }
Polynomial >> homogenizedIn: anIndeterminate [
	"Answer the homogenization of the receiver in the given indeterminate.
	Assume the indeterminate is in its species (not a new indeterminate)."
	| degree |
	degree := self degree.
	^ self monomialsApply: [:each| each complete: degree in: anIndeterminate]
]

{ #category : #'accessing coefficients' }
Polynomial >> independentCoefficient [
	"Answer the coefficient of the constant monomial of the receiver."

	^ self at: self parent monomials identity
]

{ #category : #'accessing indeterminates' }
Polynomial >> indeterminates [
	"Answer the indeterminates effectively present in this polynomial."
	^ self parent indeterminates select: [:each| self has: each]
]

{ #category : #factorization }
Polynomial >> integerContent [
	"Answer the integer content of the receiver.
	NOTE: the receiver is a polynomial over the rational numbers."

	| num den |
	self isZero ifTrue: [^ self].
	num := self leadingCoefficient numerator.
	den := self leadingCoefficient denominator.
	self coefficientsDo: [:each|
		num := num gcd: each numerator.
		den := den lcm: each denominator].
	^ (num / den) abs
]

{ #category : #factorization }
Polynomial >> integerPrimitive [
	"Answer the integer primitive polynomial associated to the receiver.
	Remove the integer content and the sign.
	NOTE: the receiver is a polynomial over the rational numbers."

	self isZero ifTrue: [^ self].
	^ self / (self integerContent * self sign)
]

{ #category : #testing }
Polynomial >> is: aSymbol [
	^ aSymbol == #Polynomial or: [super is: aSymbol]
]

{ #category : #testing }
Polynomial >> isAffineLinear [
	^ self degree < 2
]

{ #category : #testing }
Polynomial >> isBasicIrreducible [
	(self scalars isKindOf: PrimeRing) ifFalse: [DomainError signal].
	^ '(self apply: self scalars  self scalars primeSubfield) isIrreducible'
]

{ #category : #testing }
Polynomial >> isBinomial [
	^ self monomials size = 2
]

{ #category : #printing }
Polynomial >> isBroken [
	self monomials do: [:each|
		each indeterminates do: [:i| (self parent has: i) ifFalse: [^ true]].
		each exponents size = self parent rank ifFalse: [^ true]].
	^ self coefficients anySatisfy: [:any| (self parent scalars includes: any) not]
]

{ #category : #testing }
Polynomial >> isConstant [
	^ self degree < 1
]

{ #category : #testing }
Polynomial >> isHomogeneous [
	| n |
	n := self degree.
	self monomials do: [ :each | each degree = n ifFalse: [^ false]].
	^ true
]

{ #category : #testing }
Polynomial >> isIrreducible [
	self isConstant ifTrue: [^ false]. "constant polynomials are not reducible nor irreducible"
	self degree = 1 ifTrue: [^ true].
	^ self factors size = 1
]

{ #category : #testing }
Polynomial >> isLinear [
	^ self degree < 2 and: [self independentCoefficient isZero]
]

{ #category : #testing }
Polynomial >> isMonic [
	^ self leadingCoefficient = self scalars one
]

{ #category : #testing }
Polynomial >> isMonomial [
	^ self monomials size = 1
]

{ #category : #testing }
Polynomial >> isPrimitive [
	"A polynomial is primitive if it has content unity."
	^ self content = self scalars one
]

{ #category : #testing }
Polynomial >> isSeparable [
	"A polynomial over a field K is separable if it's roots are distinct in an algebraic closure of K."
	^ (self gcd: self derivative) isConstant
]

{ #category : #testing }
Polynomial >> isSquareFree [
	self isMonomial ifTrue: [^ self monomials anyOne isSquareFree].
	^ self isZero not and: [(self gcd: self derivative) isConstant]
]

{ #category : #testing }
Polynomial >> isUnivariate [
	^ self parent isUnivariate
]

{ #category : #testing }
Polynomial >> isUnivariateIn: anInteger [
	"Answer true if the receiver is an univariate polynomial in the anInteger-th indeterminate."
	(anInteger = 1 and: [self parent isUnivariate]) ifTrue: [^ true].
	self monomialsDo: [:each| (each isUnivariateIn: anInteger) ifFalse: [^ false]].
	^ true
]

{ #category : #'arithmetic-private' }
Polynomial >> karatsubaMultiplyBy: aPolynomial [
	"Ref: Zippel pp 119. O(n^1.56)"
	| n h f0 f1 g0 g1 f0g0 f1g1 |
	n := self degree.
"	self assert: aPolynomial degree = n."
	self assert: self isUnivariate.
	h := n // 2.
	f0 := self >> h. f1 := self - (f0 << h).
	g0 := aPolynomial >> h. g1 := aPolynomial - (g0 << h).
	f0g0 := f0 * g0.
	f1g1 := f1 * g1.
	^ f0g0 << (2*h) + ((f1+f0)*(g1+g0) - f0g0 - f1g1 << h) + f1g1
]

{ #category : #arithmetic }
Polynomial >> lcm: aPolynomial [
	"Answer the least common multiple of the receiver and aPolynomial."

	^ (self exactlyDividedBy: (self gcd: aPolynomial)) * aPolynomial
]

{ #category : #'accessing terms' }
Polynomial >> leadingForm [
	"Answer the homogeneous component of the lowest degree.
	This makes sense for a local ordering."
	self ordering isLocal ifFalse: [self error: 'not a local ordering'].
	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self formAt: self order]
]

{ #category : #'accessing indeterminates' }
Polynomial >> leadingIndeterminate [
	"Answer the main (or leading) indeterminate of the receiver (according to a monomial ordering)."
	| indeterminates |
	indeterminates := self ordering indeterminates.
	indeterminates reverseDo: [:i| (self has: i) ifTrue: [^ i]].
	^ indeterminates first
]

{ #category : #'accessing terms' }
Polynomial >> leadingTerm [
	"Answer the first term of the receiver."

	^ self isZero
		 ifTrue: [self]
		 ifFalse: [self termAt: self leadingMonomial]
]

{ #category : #operations }
Polynomial >> length [
	self isZero ifTrue: [^ 0].
	^ self coefficients sum: [:each| each height]
]

{ #category : #accessing }
Polynomial >> lift [
	"If the coefficients ring is a quotient R/I, nswer a representative of the receiver over R. See >>%."
	^ self apply: self scalars lifting
]

{ #category : #'accessing terms' }
Polynomial >> linearForm [
	^ self formAt: 1
]

{ #category : #converting }
Polynomial >> monic [
	^ self / self leadingCoefficient
]

{ #category : #'accessing monomials' }
Polynomial >> monomials [
	"Answer the collection of monomials effectively present in this polynomial (with non-zero coefficient). This is called the 'support' of a polynomial."
	^ Iterator on: self performing: #monomialsDo:
]

{ #category : #operations }
Polynomial >> norm [
	"Answer the euclidean norm of the receiver."
	^ self norm2 squareRoot
]

{ #category : #operations }
Polynomial >> norm1 [
	"Answer the 1-norm (or taxicab norm, or Manhattan norm) of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each abs]
]

{ #category : #operations }
Polynomial >> norm2 [
	"Answer the squared norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x + each squared]
]

{ #category : #operations }
Polynomial >> normInfinite [
	"Answer the infinite norm of the receiver.
	(In finite-dimensional vector spaces it's the same as the maximum norm)."
	^ self normMax
]

{ #category : #operations }
Polynomial >> normMax [
	"Answer the maximum norm of the receiver."
	^ self coefficients inject: self scalars zero into: [:x :each| x max: each abs]
]

{ #category : #accessing }
Polynomial >> numerator [
	"Considering the receiver as an element of the fraction ring, answer the numerator."
	^ self
]

{ #category : #constants }
Polynomial >> one [
	^ self parent one
]

{ #category : #'accessing monomials' }
Polynomial >> order [
	"Answer the minimum degree of the monomials present in the receiver."

	^ self isZero ifTrue: [Infinity negative] ifFalse: [self monomials min: [:each| each degree]]
]

{ #category : #converting }
Polynomial >> orderedBy: aMonomialOrdering [
	"Answer a copy of the receiver with a different monomial ordering."
	^ (self parent orderedBy: aMonomialOrdering) ! self
]

{ #category : #'accessing monomials' }
Polynomial >> ordering [
	"Answer the monomial ordering of the receiver."
	^ self parent ordering
]

{ #category : #'accessing-private' }
Polynomial >> parent [
	^ parent
]

{ #category : #'accessing-private' }
Polynomial >> parent: aPolynomialRing [
	parent := aPolynomialRing
]

{ #category : #'accessing terms' }
Polynomial >> parts [
	^ Iterator on: self performing: #partsDo:
]

{ #category : #operations }
Polynomial >> permutedBy: aPermutation [
	"Permute the variables of the receiver. The argument can be an Array (a permutation in 'image format'). For example given a polynomial in x,z,y, #(1 2 3) doesn't change anything, and #(2 1 3) exchanges variables x and y."
	^ self monomialsApply: [:each| each permutedBy: aPermutation]
]

{ #category : #arithmetic }
Polynomial >> pgcd: aPolynomial [
	"Answer the greatest common divisor of the receiver and aPolynomial using a probabilistic algorithm."
	| f g maps samples n |
	(self parent scalars isKindOf: RationalIntegerRing) ifFalse: [^ DomainError signal: 'polynomial not in Z[x]'].
	f := self integerPrimitive.
	g := aPolynomial integerPrimitive.
	n := f degree max: g degree.
	maps := OrderedCollection new: n + 1.
	samples := 1 to: n.
	samples do:
		[:each| maps add: each -> ((f value: each) gcd: (g value: each))].
	^ self parent interpolate: maps
]

{ #category : #'remainder sequences' }
Polynomial >> pprs: aPolynomial [
	"Answer the Primitive Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	answer := OrderedCollection new.
	f1 := self.
	answer add: f1.
	r := aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 := f1.
			f1 := r.
			r := (f0 pseudoRem: f1) primitive].
	^ answer
]

{ #category : #factorization }
Polynomial >> primitive [
	"Answer the primitive part of the receiver."
	self isZero ifTrue: [^ self].
	^ self /// self content
]

{ #category : #printing }
Polynomial >> printCoefficient: coefficient on: aStream [
	| c |
	((c := coefficient) printString first = $- "or: [coefficient isNumber and: [coefficient negative]]")
		ifTrue: [aStream nextPut: $-. c := c negated].
	((c isKindOf: Polynomial) and: [c isMonomial])
		ifTrue: [aStream print: c. ^ self].
	(c printString allSatisfy: [:each| each isAlphaNumeric or: ['{}()/' includes: each]])
		ifTrue: [aStream print: c. ^ self].
	aStream nextPut: $(; print: c; nextPut: $)
]

{ #category : #printing }
Polynomial >> printOn: aStream [
	| monomials leadingMonomial c |
	self isBroken ifTrue: [aStream nextPutAll: '(broken) '].
	(self scalars isKindOf: ModularIntegerRing)
		ifTrue: [self lift printOn: aStream. ^ self].
	self isConstant ifTrue: [aStream print: self leadingCoefficient. ^ self].
	monomials := self monomials asSortedCollection reversed.
	c := self at: (leadingMonomial := monomials first).
	(c printString first = $- or: [(c isKindOf: Number) and: [c negative]])
		ifTrue: [c := c negated. aStream nextPut: $-].
	(c ~= parent scalars one or: [leadingMonomial degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
	leadingMonomial degree > 0 ifTrue: [aStream print: leadingMonomial].
	monomials allButFirst do: [:m|
		c := self at: m.
		(c printString first = $- or: [(c isKindOf: Number) and: [c negative]])
			ifTrue: [aStream nextPutAll: ' - '. c := c negated]
			ifFalse: [aStream nextPutAll: ' + '].
		(c ~= parent scalars one or: [m degree = 0]) ifTrue: [self printCoefficient: c on: aStream].
		m degree > 0 ifTrue: [aStream print: m]]
]

{ #category : #'remainder sequences' }
Polynomial >> prs: aPolynomial [
	"Answer the Polynomial Remainder Sequence of the receiver with the argument."
	| answer f0 f1 r |
	self parent scalars isField ifFalse: [^ DomainError signal: 'scalars are not a field'].
	answer := OrderedCollection new.
	f1 := self.
	answer add: f1.
	r := aPolynomial.
	[r isZero]
		whileFalse:
			[answer add: r.
			f0 := f1.
			f1 := r.
			r := f0 \\ f1].
	^ answer
]

{ #category : #arithmetic }
Polynomial >> pseudoDivisionBy: aPolynomial [
	"Answer a pseudo-division algorithm to divide the receiver by aPolynomial."
	self isUnivariate ifFalse: [^ DomainError signal: 'polynomial is not univariate'].
	self scalars isUFD ifFalse: [^ DomainError signal: 'polynomial not over a UFD'].
	^ PolynomialPseudoDivision divide: self by: aPolynomial
]

{ #category : #arithmetic }
Polynomial >> pseudoDivisionBy: aPolynomial in: anIndeterminate [
	^ (self asUnivariateIn: anIndeterminate) pseudoDivisionBy: (aPolynomial asUnivariateIn: anIndeterminate)
]

{ #category : #arithmetic }
Polynomial >> pseudoQuo: aPolynomial [
	"Answer the quotient of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) quotient asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) quotient
]

{ #category : #arithmetic }
Polynomial >> pseudoRem2: aPolynomial [
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) remainder
]

{ #category : #arithmetic }
Polynomial >> pseudoRem3: aPolynomial [
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n d b w k |
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n := aPolynomial degree) ifTrue: [^ self].
	w := self.
	d := self degree - n + 1.
	b := aPolynomial leadingCoefficient.
	[k := w degree - n.
	w := b * w - ((self parent coefficient: w leadingCoefficient degree: k)*aPolynomial).
	w isZero ifTrue: [^ w].
	'w degree < n ifTrue: [^ w * (b ^ k)]'.
	'k > d ifTrue: [w := w * (b ^ (k - d))]'] repeat
]

{ #category : #arithmetic }
Polynomial >> pseudoRem4: aPolynomial [
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	| n b w e k |
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	"^ (self pseudoDivisionBy: aPolynomial) remainder"
	self degree < (n := aPolynomial degree) ifTrue: [^ self].
	w := self.
	e := self degree - n + 1.
	b := aPolynomial leadingCoefficient.
	[k := w degree - n.
	w := w * b - ((aPolynomial shift: k) * w leadingCoefficient).
	w isZero ifTrue: [^ w].
	'w degree < n ifTrue: [^ w * (b ^ k)]'.
	'k > e ifTrue: [w := w * (b ^ (k - e))]'] repeat
]

{ #category : #arithmetic }
Polynomial >> pseudoRem: aPolynomial [
	"Answer the remainder of the pseudo-division of the receiver by the argument."
	self isUnivariate ifFalse: [^ (self pseudoDivisionBy: aPolynomial in: self leadingIndeterminate) remainder asMultivariate].
	^ (self pseudoDivisionBy: aPolynomial) remainder
]

{ #category : #arithmetic }
Polynomial >> raiseTo: anInteger [
	"Answer the receiver raised to the power anInteger."
	anInteger = 1 ifTrue: [^ self].
	anInteger = 0 ifTrue: [^ self one].
	anInteger < 0 ifTrue: [^ '(self ^ anInteger negated) reciprocal'].
	^ 'self squared ^ (anInteger // 2) * (self ^ (anInteger \\ 2))'
]

{ #category : #arithmetic }
Polynomial >> raisedTo2: anInteger modulo: anObject [
	"Answer the receiver raised to the power anInteger modulo anObject.
	The argument anInteger must be positive."

	| result y n |
	result := self one.
	n := anInteger abs.
	y := self \\ anObject.
	[n > 0]
		whileTrue:
			[n odd ifTrue: [result := result * y \\ anObject].
			y := y squared \\ anObject.
			n := n // 2].
	^ anInteger negative ifTrue: [result reciprocal] ifFalse: [result]
]

{ #category : #arithmetic }
Polynomial >> raisedTo: anInteger modulo: aPolynomial [
	"Answer the receiver raised to the power anInteger modulo aPolynomial.
	The argument anInteger must be positive."

	anInteger = 0 ifTrue: [^ 1].
	anInteger = 1 ifTrue: [^ self \\ aPolynomial].
	^ (self squared \\ aPolynomial raisedTo: anInteger // 2 modulo: aPolynomial) * (self raisedTo: anInteger \\ 2 modulo: aPolynomial) \\ aPolynomial
]

{ #category : #arithmetic }
Polynomial >> reciprocal [
	"Answer the reciprocal of the receiver, possibly as a rational function, assuming the scalars are a field."
	self isConstant ifTrue: [^ self parent constant: self independentCoefficient reciprocal].
	^ self one / self
]

{ #category : #accessing }
Polynomial >> representative [
	"If the coefficients ring is a quotient R/I, nswer a representative of the receiver over R. See >>%."
	^ self apply: self scalars projection section
]

{ #category : #operations }
Polynomial >> s: aPolynomial [
	"Answer the S-polynomial of the receiver with the argument."
	| h1 h2 lcm |
	h1 := self leadingMonomial.
	h2 := aPolynomial leadingMonomial.
	lcm := h1 lcm: h2.
	^ self * (lcm / h1) / self leadingCoefficient - (aPolynomial * (lcm / h2) / aPolynomial leadingCoefficient)
]

{ #category : #accessing }
Polynomial >> scalars [
	^ parent scalars
]

{ #category : #factorization }
Polynomial >> sign [
	"Answer the sign of the receiver, i.e. the sign if its head coefficient."

	^ self leadingCoefficient sign
]

{ #category : #'remainder sequences' }
Polynomial >> sprs2: aPolynomial [
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta b phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	delta := self degree - aPolynomial degree + 1.
	b := aPolynomial leadingCoefficient.
	phi := 'b ^ (delta - 1)'.
	beta := '(-1) ^ delta'.
	answer := OrderedCollection new.
	answer add: self; add: aPolynomial.
	f1 := aPolynomial. f2 := self. "f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	[r := (f2 pseudoRem: f1) / beta.
	r isZero ifTrue: [^ answer].
	answer add: r. f2 := f1. f1 := r.
	delta := f1 degree - r degree + 1.
	beta := '(-1) ^ delta * (phi ^ (delta - 1)) * b'.
	b := r leadingCoefficient.
	phi := 'phi * ((b / phi) ^ (delta - 1))'] repeat
]

{ #category : #'remainder sequences' }
Polynomial >> sprs: aPolynomial [
	"Answer the Subresultant Polynomial Remainder Sequence of the receiver with the argument."
	| delta phi beta f1 f2 r answer |
	self assert: self scalars isUFD.
	self assert: self degree >= aPolynomial degree.
	f2 := self. f1 := aPolynomial."f1 is F_{i-1}, f2 is F_{i-2}, r is F_i"
	phi := self scalars one.
	answer := OrderedCollection new.
	answer add: f2.
	[f1 isZero]
		whileFalse:
			[answer add: f1.
			delta := f2 degree - f1 degree + 1.
			beta := '(-1) ^ delta * (phi ^ (delta - 1)) * f2 leadingCoefficient'.
			phi := 'phi * ((f1 leadingCoefficient / phi) ^ (delta - 1))'.
			r := (f2 pseudoRem: f1) /// beta.
			f2 := f1. f1 := r].
	^ answer
]

{ #category : #operations }
Polynomial >> squareFree [
	"Answer the maximal squarefree divisor of the receiver."
	| g |
	self parent scalars characteristic = 0 ifFalse: [^ DomainError signal: 'field must include Q (i.e., must be of characteristic 0)'].
	g := self.
	self indeterminates do: [:each| g := g gcd: (self derivativeIn: each)].
	^ self /// g
]

{ #category : #arithmetic }
Polynomial >> squared [
	^ self * self
]

{ #category : #operations }
Polynomial >> substitute: aBlock [
	"Answer the receiver after substituting indeterminates by aBlock."
	^ self monomialsApply: [:each| each substitute: aBlock]
]

{ #category : #'accessing monomials' }
Polynomial >> support [
	"Answer the collection of monomials effectively present in this polynomial (with non-zero coefficient)."
	^ self monomials
]

{ #category : #'accessing terms' }
Polynomial >> tail [
	^ self - self leadingTerm
]

{ #category : #'accessing terms' }
Polynomial >> termAt: aMonomial [
	^ self parent coefficient: (self at: aMonomial) monomial: aMonomial
]

{ #category : #'accessing terms' }
Polynomial >> terms [
	^ Iterator on: self performing: #termsDo:
]

{ #category : #enumerating }
Polynomial >> termsDo: aBlock [
	self partsDo: [:each| aBlock value: (self parent coefficient: each value monomial: each key)]
]

{ #category : #operations }
Polynomial >> value: anObject [
	"Answer the value of the receiver at the argument. For multivariate polynomials, a Tuple or Array is expected."
	| answer one |
"	((anObject is: #Tuple) or: [anObject is: #Array])
		ifFalse: [^ self error: 'argument should be tuple or array']."
	anObject size = self parent rank
		ifFalse: [self error: 'the arity of the argument should match the number of indeterminates'].
	answer := (anObject at: 1) zero.
	one := answer one.
	self partsDo: [:each|
		| monomial |
		monomial := each key.
		answer := (monomial isIdentity ifTrue: [one * each value] ifFalse: [(monomial value: anObject) * each value]) + answer].
	^ answer
]

{ #category : #operations }
Polynomial >> valueWithArguments: anArray [
	^ self value: anArray
]

{ #category : #constants }
Polynomial >> zero [
	^ self parent zero
]

{ #category : #testing }
Polynomial >> | aPolynomial [
	"Answer true if the receiver divides aPolynomial."
	self scalars isField ifTrue: [^ (aPolynomial \\ self) isZero].
	^ (aPolynomial pseudoRem: self) isZero
]

{ #category : #arithmetic }
Polynomial >> î [ anObject
	"Answer the composition of the receiver with the argument."
	anObject isBlock ifTrue: [^ [:x| self value: (anObject value: x)]].
	^ self value: anObject
]
