Class {
	#name : #CommutativeAlgebraTest,
	#superclass : #TestCase,
	#category : #'Mathematics-Tests'
}

{ #category : #'affine ring' }
CommutativeAlgebraTest >> testAffineRingElementOperations [
	"Magma handbook example H105E1."

	| R A x y |
	R := QQ polynomialsIn: #(x y).
	A := R
		/
			(R
				generate: [ :x1 :y1 | 
					{((x1 raisedTo: 2) - (y1 raisedTo: 2) + 2).
					((y1 raisedTo: 3) - 5)} ]).
	x := A x.
	y := A y.
	self assert: (x raisedTo: 2) equals: (y raisedTo: 2) - 2
]

{ #category : #'affine ring' }
CommutativeAlgebraTest >> testAffineRingIdealIntersectionRandom [
	| R f1 f2 J A |
	R := QQ polynomialsIn: #(x y).
	[(f1 := R atRandomBits: 10) isZero] whileTrue.
	[(f2 := R atRandomBits: 10) isZero] whileTrue.
	J := R * {f1. f2}.
	A := R/J.
	self testIdealIntersectionRandom: A
]

{ #category : #'affine ring' }
CommutativeAlgebraTest >> testAffineRingIdealMembershipRandom [
	| R f1 f2 J A g I h |
	R := QQ polynomialsIn: #(x y z).
	[(f1 := R atRandomBits: 10) isZero] whileTrue.
	[(f2 := R atRandomBits: 10) isZero] whileTrue.
	J := R * {f1. f2}.
	A := R/J.
	g := A atRandomBits: 10.
	I := A * g.
	h := I atRandomBits: 10.
	self assert: (I includes: h)
]

{ #category : #'affine ring' }
CommutativeAlgebraTest >> testAffineRingIdealOperations [
	"Magma handbook, example H105E2."

	| R A I J |
	R := QQ polynomialsIn: #(x y z).	"ordering: #lex"
	A := R
		/
			(R
				generate: [ :x :y :z | 
					{((x raisedTo: 2) - y + 1).
					((y raisedTo: 3) + z - 1)} ]).
	I := A
		* (A generate: [ :x :y :z | (x raisedTo: 3) * y * (z raisedTo: 2) ]).
	self deny: I isRadical.
	J := A
		*
			(A
				generate: [ :x :y :z | 
					{(x * (y raisedTo: 2) + (x * y) - (x * z) + x).
					(y * z).
					((z raisedTo: 2) - z)} ]).
	self assert: I radical equals: J	"this fails probably because PolynomialIdeal>>radical is broken"
	"... and then some tests of primary decomposition"
]

{ #category : #'division and normal forms' }
CommutativeAlgebraTest >> testBuchbergerNormalForm [
	"A Singular Introduction to Commutative Algebra, Example 1.6.12."

	| R x y z f G h |
	R := QQ polynomialsIn: #(x y z) ordering: #glex.
	x := R x.
	y := R y.
	z := R z.
	f := (x raisedTo: 3) + (y raisedTo: 2) + ((z raisedTo: 2) * 2) + x
		+ y + 1.
	G := GroebnerBasis new
		add: R x;
		add: R y;
		yourself.
	h := G reduce: f.
	self assert: h equals: (z raisedTo: 2) * 2 + x + y + 1.
	h := G reduceFull: f.
	self assert: h equals: (z raisedTo: 2) + (1 / 2)
]

{ #category : #'testing examples' }
CommutativeAlgebraTest >> testCyclic7Correctness [
	"Test correctness of the ideal of cyclic 7-roots checking against one generated by Singular."

	| txt |
	txt := ((QQ polynomialsIn: 7) cyclicIdeal generators
		sorted: [ :a :b | a leadingMonomial >= b leadingMonomial ])
		printString.
	#('(' ')' '{' '}' ' ')
		do: [ :each | txt := txt copyReplaceAll: each with: '' ].
	self
		assert: txt
		equals:
			'x1x2x3x4x5x6x7-1,x1x2x3x4x5x6+x1x2x3x4x5x7+x1x2x3x4x6x7+x1x2x3x5x6x7+x1x2x4x5x6x7+x1x3x4x5x6x7+x2x3x4x5x6x7,x1x2x3x4x5+x2x3x4x5x6+x1x2x3x4x7+x1x2x3x6x7+x1x2x5x6x7+x1x4x5x6x7+x3x4x5x6x7,x1x2x3x4+x2x3x4x5+x3x4x5x6+x1x2x3x7+x1x2x6x7+x1x5x6x7+x4x5x6x7,x1x2x3+x2x3x4+x3x4x5+x4x5x6+x1x2x7+x1x6x7+x5x6x7,x1x2+x2x3+x3x4+x4x5+x5x6+x1x7+x6x7,x1+x2+x3+x4+x5+x6+x7'
]

{ #category : #algorithms }
CommutativeAlgebraTest >> testExtendedBuchberger [
	| I algorithm G G2 |
	I := (QQ polynomialsIn: #(a b c d)) cyclicIdeal.
	I := I orderedBy: #grevlex.
	G := (algorithm := ExtendedBuchberger on: I) basis.
	self assert: algorithm verify.
	self assert: G verify.
	G2 := (Buchberger on: I) basis.
	self assert: G reduced equals: G2 reduced.
	self
		assert: algorithm matrix * (I scalars tuple: I generators)
		equals: (I scalars tuple: G)
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerBasis: G ideal: I [
	"Test G is a Groebner basis of the ideal I."
	| g division |
	self assert: G verify.
	I generators do: [:each| self assert: (G reduces: each)].
	G do: [:each| self assert: (I includes: each)]. "but this will use Groebner bases.."
	g := I atRandomBits: 200.
	self assert: (G reduces: g).
	"The leading term of any polynomial in I is divisible by the leading term of some polynomial in G:"
	self assert: (G anySatisfy: [:any| any leadingMonomial | g leadingMonomial]).
	"The multivariate division of any polynomial in I by G gives the remainder 0:"
	division := g divisionBy: G.
	self assert: division remainder isZero.
	self assert: division verify.
	self assert: G reduced isReduced.
	self assert: G minimal isMinimal
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic3 [
	| I G |
	I := (QQ polynomialsIn: 3) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic3Lexicographic [
	| I G |
	I := (QQ polynomialsIn: 3 ordering: #lex) cyclicIdeal.
	G := I basis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic3OverZ2 [
	| I G |
	I := (ZZ / 2 polynomialsIn: 3) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic3Reduced [
	| I G |
	I := (QQ polynomialsIn: #(x y z)) cyclicIdeal.
	I := I orderedBy: #lex.
	G := I basis reduced.
	self
		assert: G printString
		equals: '{x + y + z, y^2 + yz + z^2, z^3 - 1}'
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic3TotalLexicographic [
	| I G |
	I := (QQ polynomialsIn: 3 ordering: #glex) cyclicIdeal.
	G := I basis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic3TotalReverseLexicographic [
	| I G |
	I := (QQ polynomialsIn: 3 ordering: #grevlex) cyclicIdeal.
	G := I basis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic4 [
	| I G |
	I := (QQ polynomialsIn: 4) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic4OverZ127 [
	| I G |
	I := (ZZ / 127 polynomialsIn: 4) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic4OverZ2 [
	| I G |
	I := (ZZ/2 polynomialsIn: 4) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic5 [
	| I G |
	I := (QQ polynomialsIn: 5) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic5OverZ127 [
	| I G |
	I := (ZZ/127 polynomialsIn: 5) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic5OverZ2 [
	| I G |
	I := (ZZ/2 polynomialsIn: 5) cyclicIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerCyclic5Reduced [
	| I G |
	I := (QQ polynomialsIn: 5) cyclicIdeal.
	G := I groebnerBasis reduced.
	self assert: G isReduced.
	self testGroebnerBasis: G ideal: I.
	self assert: (I scalars * G) groebnerBasis reduced = G
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerExample [
	| P x y z I G |
	P := QQ polynomialsIn: #(x y z) ordering: #lex.
	x := P x.
	y := P y.
	z := P z.
	I := P
		*
			{((x raisedTo: 2) - (y * z)).
			((y raisedTo: 2) - (z * x)).
			((z raisedTo: 2) - (x * y))}.
	G := I basis minimal.
	self
		assert: G asSet
		equals:
			{((x raisedTo: 2) - (y * z)).
			(x * z - (y raisedTo: 2)).
			(x * y - (z raisedTo: 2)).
			((y raisedTo: 3) - (z raisedTo: 3))} asSet
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerExample2 [
	| R x y f1 f2 I G |
	R := QQ polynomialsIn: #(x y) ordering: #lex.
	x := R x.
	y := R y.
	f1 := (x - 1 raisedTo: 2) + (y - 2 raisedTo: 2) - (3 raisedTo: 2).
	f2 := (x + 1 raisedTo: 2) + (y - 1 raisedTo: 2) - (2 raisedTo: 2).
	I := R
		*
			{f1.
			f2}.
	G := I basis reduced.
	self
		assert: G printString
		equals:
			' End of statement list encountered ->{x + (1/2)y + (1/2), y^2 - 2y - (11/5)}'
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerExample3 [
	"From some question in math.stackexchange.com."

	| R I G |
	R := QQ polynomialsIn: #(x y) ordering: #glex.
	I := R
		*
			(R
				! [ :x :y | 
					{((x raisedTo: 2) * y + x + 1).
					(x * (y raisedTo: 2) + y + 1).
					(x - y)} ]).
	G := I basis reduced.
	self assert: G printString equals: '{y^3 + y + 1, x - y}'	"this is as computed by Singular"
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerExample4Minimal [
	"Example from Cox, Little, O'Shea, 'Ideals, Varieties and Algorithms', p. 90, continued in p. 93."

	| R I G |
	R := QQ polynomialsIn: #(x y) ordering: #grevlex.
	I := R
		*
			(R
				! [ :x :y | 
					{((x raisedTo: 3) - (x * y * 2)).
					((x raisedTo: 2) * y - ((y raisedTo: 2) * 2) + x)} ]).
	G := I basis minimal.
	self assert: G printString equals: '{x^2, xy, y^2 - (1/2)x}'
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerKatsura2 [
	| I G |
	I := (QQ polynomialsIn: 2) katsuraIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerKatsura3 [
	| I G |
	I := (QQ polynomialsIn: 3) katsuraIdeal.
	G := I groebnerBasis.
	self testGroebnerBasis: G ideal: I
]

{ #category : #groebner }
CommutativeAlgebraTest >> testGroebnerTrivial [
	"The 3 polynomials have no common zeroes, the Groebner basis should be {1}."

	| Qx x y I |
	Qx := QQ polynomialsIn: #(x y) ordering: #lex.
	x := Qx x.
	y := Qx y.
	I := Qx * {x + y. (x raisedTo: 2) - 1. (y raisedTo: 2) - (x*2)}.
	self assert: I groebnerBasis minimal isTrivial
]

{ #category : #'hilbert series' }
CommutativeAlgebraTest >> testHilbertSeriesOfPolynomialIdeal [
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t := QQ polynomials fractions x.
	R := QQ polynomialsIn: #(x y z w) "ordering: #lex".
	x := R x.
	y := R y.
	z := R z.
	w := R x: 4.
	I := 'R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}'.
	H := I hilbertSeriesAt: t.
	self assert: 'H = (t^2 * 3 - (t^3 * 2) / ((1 - t) ^ 4))'
]

{ #category : #'hilbert series' }
CommutativeAlgebraTest >> testHilbertSeriesOfPolynomialQuotient [
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H |
	t := QQ polynomials fractions x.
	R := QQ polynomialsIn: #(x y z w) "ordering: #lex".
	x := R x.
	y := R y.
	z := R z.
	w := R x: 4.
	I := 'R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}'.
	H := (R/I) hilbertSeriesAt: t.
	self assert: H = (1 + (2*t) / (1 - t) squared)
]

{ #category : #'hilbert series' }
CommutativeAlgebraTest >> testHilbertSeriesOfPolynomialQuotient2 [
	"Derksen, Kemper 'Computational Invariant Theory', Example 1.4.9."
	| t R x y z w I H dim deg |
	t := QQ polynomials fractions x.
	R := QQ polynomialsIn: #(x y z w).
	x := R x.
	y := R y.
	z := R z.
	w := R x: 4.
	I := 'R * {x*z - (y^2). x*w - (y*z). y*w - (z^2)}'.
	H := (R/I) hilbertSeriesAt: t.
	dim := (H orderAt: 1) negated.
	self assert: (R/I) dimension = dim.
	deg := 'H * ((1 - H numerator parent x) ^ dim) value: 1'. "should be limit from below"
	self assert: (R/I) degree = deg
]

{ #category : #'hilbert series' }
CommutativeAlgebraTest >> testHilbertSeriesOfPolynomialRing [
	| t R H |
	t := QQ polynomials fractions x.
	R := QQ polynomialsIn: 4.
	H := R hilbertSeriesAt: t.
	self assert: 'H = ((1 - t) ^ -4)'
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealColon [
	| R x y z I J |
	R := QQ polynomialsIn: #(x y z).
	x := R x.
	y := R y.
	z := R z.
	'I := R * {x*y - 1. x^3*(z^2) - (y^2). x*(z^3) - x - 1}'.
"	J := R * {x*y - 1. x^2*z - y. x*(z^3) - x - 1}."
	'self assert: I ˜ R asIdeal = I.
		self assert: R asIdeal ˜ I = R asIdeal'.
	J := R * {I atRandomBits: 10. I atRandomBits: 10}. "J <= I"
	self assert: 'I ˜ J = R asIdeal'
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealColon2 [
	"Example from Cox IVA 205p."
	| R x y z I J Q |
	R := QQ polynomialsIn: #(x y z).
	x := R x.
	y := R y.
	z := R z.
	I := 'R * {x*z - (y raiseTo: 2). x^3 - (y*z)}'.
	J := R * {x. y}.
	'Q := I ˜ J'.
	'self assert: Q = (I ˜ (R * x) ï (I ˜ (R * y))).
		self assert: Q = (R * {x*z - (y^2). x^3 - (y*z). x^2*y - (z^2)})'
]

{ #category : #'ideal basics' }
CommutativeAlgebraTest >> testIdealElementOperations [
	"Magma handbook example H103E2."
	| R x y z I |
	R := QQ polynomialsIn: #(x y z) "ordering: #lex".
	x := R x. y := R y. z := R z.
	'I := R * {(x + y)^3. (y - z)^2. y^2*z + z}'.
	'self assert: (I reduce: (y^2*z + z)) isZero'.
	"I basis reduceFull: x^3 = ..."
	"I basis reduce: z^4 + (y^2))"
	self deny: (I includes: x+y).
	self assert: (I radicalContains: x+y).
	self assert: (I radicalContains: (x+y) raiseTo: 2).
	self deny: (I radicalContains: z).
	'self assert: (x^4 + y - z s: x^2 + y - z) = (x^2*y negated + (x^2*z) + y - z)'
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealElimination [
	"Example from Cox IVA 123 p. NOTE: this is a little slow."
	| Qx x y z I |
	Qx := QQ polynomialsIn: #(x y z).
	x := Qx x. y := Qx y. z := Qx z.
	'I := Qx * {x^2 + y + z - 1. x + (y^2) + z - 1. x + y + (z^2) - 1}'.
	'self assert: (I eliminateAll: #(1 2)) generator = (z^6 - (z^4*4) + (z^3*4) - (z^2))'
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealEqualsUnitIdeal [
	| R x y I |
	R := ZZ/7 polynomialsIn: #(x y) ordering: #glex.
	x := R x.
	y := R y.
	I := R * {x + 1. x - 1. y - 2}.
	self assert: I = R oneIdeal
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealHomogenization [
	"The homogenization of an ideal can be bigger than the ideal generated by the homogenized generators."
	| Qx x y z f1 f2 I f3 J |
	Qx := QQ polynomialsIn: #(x y z).
	x := Qx x.
	y := Qx y.
	z := Qx z.
	"Ideal for the twisted cubic:"
	f1 := y - (x raiseTo: 2).
	f2 := z - (x raiseTo: 3).
	I := Qx * {f1. f2}.
	"Now a polynomial in I:"
	f3 := f2 - (f1*x).
	self assert: (I homogenized includes: f3 homogenized).
	"But it's not in the ideal generated by the homogenized generators:"
	J := Qx * {f1 homogenized. f2 homogenized}.
	self deny: (J includes: f3 homogenized)
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealIntersection [
	"Example from Cox IVA 194 p."
	| Qxy x y I J K |
	Qxy := QQ polynomialsIn: #(x y).
	x := Qxy x.
	y := Qxy y.
	I := Qxy * {(x raisedTo: 2) * y}.
		J := Qxy * {x * (y raisedTo: 2)}.
		K := Qxy * {(x raisedTo: 2)*(y raisedTo: 2)}.
	self assert: 'I ï J = K'
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealIntersectionRandom [
	self testIdealIntersectionRandom: (QQ polynomialsIn: #(x y))
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealIntersectionRandom: aRing [
	| R f1 f2 g I J K |
	R := aRing.
	f1 := R atRandomBits: 10.
	f2 := R atRandomBits: 10.
	g := R atRandomBits: 10.
	I := R * {f1. g}.
	J := R * {f2. g}.
	K := R * {g}.
	self assert: I ï J >= K
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealIsPrime [
	| R x y I |
	R := QQ polynomialsIn: #(x y).
	x := R x: #x.
	y := R x: #y.
	I := R * {(x raisedTo: 2) - (y raisedTo: 2) - 1}.
	self assert: I isPrime
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealIsRadical [
	"Becker, Weispfenning, 'Groebner Bases', Exercise 8.21."

	| R x y I |
	R := QQ polynomialsIn: #(x y).
	x := R x: #x.
	y := R x: #y.
	I := R
		*
			{((x raisedTo: 2) + y).
			((y raisedTo: 2) + x)}.
	self assert: I dimension equals: 0.
	self assert: I isRadical
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembership [
	| Qxy x y f g I J h k |
	Qxy := QQ polynomialsIn: #(x y).
	x := Qxy x.
	y := Qxy y.
	f := (x raisedTo: 2) - y.
	g := (x raisedTo: 3) - x.
	I := Qxy
		*
			{f.
			g}.
	J := Qxy
		*
			{(x raisedTo: 2).
			(y raisedTo: 3)}.
	h := (y raisedTo: 2) - y.
	k := x * y - x.
	self assert: (I includes: h).
	self assert: (I includes: k).
	self assert: (J includes: h) not.
	self assert: (J includes: k) not
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembership2 [
	| Qxy x y I |
	Qxy := QQ polynomialsIn: #(x y).
	x := Qxy x.
	y := Qxy y.
	I := Qxy * {x*x. y*2 + x}.
	self assert: (I includes: (x + y) squared)
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembership3 [
	| Qx x y z w f g I |
	Qx := QQ polynomialsIn: #(x y z w).
	x := Qx x.
	y := Qx y.
	z := Qx z.
	w := Qx x: #w.
	f := x * z - (y raisedTo: 2).	"twisted cubic"
	g := z * (y * w - (z raisedTo: 2)) - (w * (x * w - (y * z))).
	I := Qx
		*
			{f.
			g}.
	"The twisted cubic C in P^3 is the set-theoretic complete intersection
	of f=0 and g=0, but not a scheme-theoretic or ideal-theoretic complete
	intersection (the ideal is not radical since includes f^2):"
	self assert: (I includes: (f raisedTo: 2))
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembership4 [
	| R x y z I |
	R := ZZ / 127 polynomialsIn: #(x y z) ordering: #glex.
	x := R x.
	y := R y.
	z := R z.
	I := R * {x*y + z. (y  raisedTo: 3) + 1. (z raisedTo: 2) - (x*5) - 1}.
	self assert: (I includes: (x*y + z) + ((y raisedTo: 3) + 1)).
		self assert: (I includes: x*z*((z raisedTo:2) - (x*5) - 1))
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembership5 [
	| R x y I |
	R := ZZ / 7 polynomialsIn: #(x y) ordering: #glex.
	x := R x.
	y := R y.
	I := R * {x*y + 1. (y raisedTo: 2) - 1}.
	self assert: (I includes: x + y)
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembershipRandom [
	self testIdealMembershipRandom: (QQ polynomialsIn: #(x y z))
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealMembershipRandom: aRing [
	| R f1 f2 f3 I g |
	R := aRing.
	[(f1 := R atRandomBits: 10) isZero] whileTrue.
	[(f2 := R atRandomBits: 10) isZero] whileTrue.
	[(f3 := R atRandomBits: 10) isZero] whileTrue.
	I := R * {f1. f2. f3}.
	g := I atRandomBits: 100.
	self assert: (I includes: g)
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealRadical [
	| R x y I J |
	R := QQ polynomialsIn: #(x y).
	x := R x: #x.
	y := R x: #y.
	I := R
		*
			{(x raisedTo: 3).
			(y raisedTo: 2)}.
	J := R
		*
			{x.
			y}.
	self assert: I radical equals: J
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealRadicalZeroDimNotPerfectField [
	"Counterexample that shows how Seidenberg algorithm fails over a non-perfect field.
	From Becker and Weispfenning 'Groebner Bases', Springer-Verlag, 1993. Example 8.16."

	| p F R t x y I |
	p := #(3 5 7 11) atRandom.
	F := (ZZ / p polynomialsIn: #(t)) fractions.
	R := F polynomialsIn: #(x y).
	t := F x: #t.
	x := R x.
	y := R y.
	I := R
		*
			{((x raisedTo: p) - t).
			((y raisedTo: p) - t)}.
	self assert: (I includes: ((x raisedTo: p) - (y raisedTo: p))).
	self deny: (I includes: x - y).
	self assert: (I radical includes: x - y)
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealRadicalZeroDimPerfectField [
	"Seidenberg algorithm works for 0-dimensional ideals over a perfect field."

	| R y z I J |
	R := QQ polynomialsIn: #(y z).
	y := R x: #y.
	z := R x: #z.
	I := R
		*
			{(y + z).
			(z raisedTo: 2)}.
	J := R
		*
			{y.
			z}.
	self assert: I radical equals: J
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testIdealSaturation [
	"Example from SageMath reference."

	| R x y z I J S |
	R := QQ polynomialsIn: #(x y z).
	x := R x.
	y := R y.
	z := R z.
	I := R
		*
			{((x raisedTo: 5) * (z raisedTo: 3)).
			(x * y * z).
			(y * (z raisedTo: 4))}.
	J := R * z.
	S := R
		*
			{y.
			(x raisedTo: 5)}.
	self assert: (I saturation: J) equals: S
]

{ #category : #'testing examples' }
CommutativeAlgebraTest >> testKatsura7Correctness [
	"Test correctness of Katsura-7 ideal checking against one generated by Singular."
	| txt |
	txt := ((QQ polynomialsIn: 7) katsuraIdeal generators sorted: [:a :b| a leadingMonomial >= b leadingMonomial]) printString.
	#('(' ')' '{' '}' ' ') do: [:each| txt := txt copyReplaceAll: each with: ''].
	self assert: txt = 'x1^2+2x2^2+2x3^2+2x4^2+2x5^2+2x6^2+2x7^2-x1,2x1x2+2x2x3+2x3x4+2x4x5+2x5x6+2x6x7-x2,x2^2+2x1x3+2x2x4+2x3x5+2x4x6+2x5x7-x3,2x2x3+2x1x4+2x2x5+2x3x6+2x4x7-x4,x3^2+2x2x4+2x1x5+2x2x6+2x3x7-x5,2x3x4+2x2x5+2x1x6+2x2x7-x6,x1+2x2+2x3+2x4+2x5+2x6+2x7-1'
]

{ #category : #'krull dimension' }
CommutativeAlgebraTest >> testKrullDimension [
	| R I Q |
	R := QQ polynomialsIn: #(x y).
	self assert: R dimension equals: 2.
	I := R
		*
			{R x.
			R y}.
	Q := R / I.
	self assert: Q dimension equals: 0.
	I := R * R zero.	"zero ideal"
	Q := R / I.
	self assert: Q dimension equals: 2
]

{ #category : #'krull dimension' }
CommutativeAlgebraTest >> testKrullDimension2 [
	"Example from SageMath."

	| R x y I |
	R := QQ polynomialsIn: #(x y).
	x := R x.
	y := R y.
	I := R
		*
			{(x * y).
			(x * y + 1)}.
	self assert: (R / I) dimension < 0.
	I := R
		*
			{(x * (x * y + 1)).
			(y * (x * y + 1))}.
	self assert: (R / I) dimension equals: 1.
	I := R
		*
			{((x raisedTo: 3) * y).
			(x * (y raisedTo: 2))}.
	self assert: (R / I) dimension equals: 1
]

{ #category : #'krull dimension' }
CommutativeAlgebraTest >> testKrullDimensionFiniteField [
	"Example from SageMath."

	| R x y I Q |
	R := ZZ / 32003 polynomialsIn: #(x y z).
	self assert: R dimension equals: 3.
	x := R x.
	y := R y.
	I := R
		*
			{((x raisedTo: 2) - y).
			(x raisedTo: 3)}.
	Q := R / I.
	self assert: Q dimension equals: 1
]

{ #category : #'krull dimension' }
CommutativeAlgebraTest >> testKrullDimensionFiniteField2 [
	"Example from SageMath."

	| R x y I |
	R := ZZ / 2147483659 polynomialsIn: #(x y).
	x := R x.
	y := R y.
	I := R
		*
			{(x * y).
			(x * y + 1)}.
	self assert: (R / I) dimension < 0.
	I := R
		*
			{(x * (x * y + 1)).
			(y * (x * y + 1))}.
	self assert: (R / I) dimension equals: 1.
	I := R
		*
			{((x raisedTo: 3) * y).
			(x * (y raisedTo: 2))}.
	self assert: (R / I) dimension equals: 1
]

{ #category : #'krull dimension' }
CommutativeAlgebraTest >> testKrullDimensionOverZZ [
	| R I Q |
	R := ZZ polynomialsIn: #(x y).
	self assert: R dimension equals: 3.
	I := R * R zero.	"zero ideal"
	Q := R / I.
	self assert: Q dimension equals: 3
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testLocalIdeals [
	"Magma handbook, example H104E4."
	| R I J A M |
	self notYetImplemented.
	R := QQ polynomialsIn: #(x y z) ordering: #llex.
	'I := R * (R generate: [:x :y :z| {x*y - z. x^3*(z^2) - (y^2). x*(z^3) - x - y}]).
		J := R * (R generate: [:x :y :z| {x*y - z. x^2*z - y. x*(z^3) - x - y}]).
		A := R * (R generate: [:x :y :z|
			{x^2 - (y^2) + (2*(x^3)*z).
			x*y + (y^2) - (x^3*z).
			y^3.
			x*z + (y*z).
			y*z.
			z^2}])'.
	self assert: I * J = A. "hangs here"
	'M := R * (R generate: [:x :y :z| {x + y. y^2. z}]).
		self assert: I ï J = M'.
	self deny: A = M.
	self assert: A <= M
]

{ #category : #'division and normal forms' }
CommutativeAlgebraTest >> testMoraNormalForm [
	"A Singular Introduction to Commutative Algebra, Example 1.7.7."

	| R f G h |
	R := QQ polynomialsIn: #(x y z) ordering: #lgrevlex.
	f := R
		! [ :x :y :z | 
			(x raisedTo: 2) + (y raisedTo: 2) + (z raisedTo: 3) + (x raisedTo: 4)
				+ (y raisedTo: 5) ].
	G := StandardBasis new
		add: R x;
		add: R y;
		yourself.
	h := G reduce: f.
	self
		assert: h
		equals: R ! [ :x :y :z | (z raisedTo: 3) + (x raisedTo: 4) + (y raisedTo: 5) ]
]

{ #category : #'division and normal forms' }
CommutativeAlgebraTest >> testMultivariateDivisionExample [
	| P x y z F f |
	P := QQ polynomialsIn: #(x y z) ordering: #glex.
	x := P x.
	y := P y.
	z := P z.
	F := {((x raisedTo: 2) - (y * z)).
	(y raisedTo: 2 - (z * x)).
	((z raisedTo: 2) - (x * y))}.
	f := (x raisedTo: 3) + ((y raisedTo: 3) * 3).
	self assert: (f divisionBy: F) remainder equals: (y raisedTo: 3) * 4
]

{ #category : #'division and normal forms' }
CommutativeAlgebraTest >> testMultivariateDivisionExample2 [
	| R f f1 f2 |
	R := QQ polynomialsIn: #(x y z) ordering: #lex.
	f := R ! [ :x :y :z | (x raisedTo: 5) * (y raisedTo: 3) ].
	f1 := R
		! [ :x :y :z | (x raisedTo: 3) * (y raisedTo: 2) - ((y raisedTo: 2) * z) ].
	f2 := R ! [ :x :y :z | x * (y raisedTo: 2) - (y * z) ].
	self
		assert:
			(f
				divisionBy:
					{f1.
					f2}) printString
		equals: 'x^5y^3 = (x^2y)(x^3y^2 - y^2z) + (xyz + z^2)(xy^2 - yz) + yz^3'
]

{ #category : #'division and normal forms' }
CommutativeAlgebraTest >> testMultivariateDivisionExample3 [
	| R f f1 f2 |
	R := QQ polynomialsIn: #(x y z) ordering: #lex.
	f := R
		! [ :x :y :z | (x raisedTo: 3) * (y raisedTo: 2) + (x * y) + x + 1 ].
	f1 := R ! [ :x :y :z | (x raisedTo: 3) + 1 ].
	f2 := R ! [ :x :y :z | (y raisedTo: 2) + 1 ].
	self
		assert:
			(f
				divisionBy:
					{f1.
					f2}) printString
		equals: 'x^3y^2 + xy + x + 1 = (y^2)(x^3 + 1) + (-1)(y^2 + 1) + xy + x + 2'
]

{ #category : #'division and normal forms' }
CommutativeAlgebraTest >> testMultivariateDivisionExample4 [
	| R f f1 f2 |
	R := QQ polynomialsIn: #(x y) ordering: #lex.
	f := R
		!
			[ :x :y | (x raisedTo: 2) * (y raisedTo: 3) - (x * (y raisedTo: 2) * 2) ].
	f1 := R ! [ :x :y | (x raisedTo: 2) * y - (x * 2) ].
	f2 := R ! [ :x :y | (y raisedTo: 3) + 4 ].
	self
		assert:
			(f
				divisionBy:
					{f1.
					f2}) printString
		equals: 'x^2y^3 - 2xy^2 = (y^2)(x^2y - 2x) + (0)(y^3 + 4) + 0'.
	self
		assert:
			(f
				divisionBy:
					{f2.
					f1}) printString
		equals: 'x^2y^3 - 2xy^2 = (x^2)(y^3 + 4) + (0)(x^2y - 2x) + -4x^2 - 2xy^2'
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testPolynomialRingHomomorphismKernel [
	| A B x y phi |
	A := QQ polynomialsIn: #(x y z).
	B := QQ polynomialsIn: #(x y).
	x := B x.
	y := B y.
	phi := A
		to: B
		evaluating: [ :f | 
			f
				value:
					{(x - y).
					x.
					y} ].
	self assert: phi kernel equals: A * (A x - A y + A z).
	self assert: (phi value: (phi kernel atRandomBits: 15)) isZero
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testRadicalMembership [
	| R x y z g1 g2 f I |
	R := QQ polynomialsIn: #(x y z).
	x := R x.
	y := R y.
	z := R z.
	g1 := (x raisedTo: 4) * (y raisedTo: 2) + (z raisedTo: 2)
		- (x * (y raisedTo: 3) * z * 4) - ((y raisedTo: 5) * z * 2).
	g2 := (x + (y raisedTo:2)) raisedTo: 2.
	f := y*z - (x raisedTo:3).
	I := R
		*
			{g1.
			g2}.
	self assert: (I radicalContains: f)
]

{ #category : #'ideal operations' }
CommutativeAlgebraTest >> testSquarefreeMonomialIdealPrimaryDecomposition [
	"Miller, Sturmfels, 'Combinatorial Commutative Algebra', Example 1.8."

	| R a b c d e I |
	R := QQ polynomialsIn: #(a b c d e).
	a := R x: 1.
	b := R x: 2.
	c := R x: 3.
	d := R x: 4.
	e := R x: 5.
	I := R
		*
			{(a * d).
			(a * e).
			(b * c * d).
			(b * e).
			(c * e).
			(d * e)}.
	self
		assert: I primaryDecomposition
		equals:
			{(R
				*
					{d.
					e}).
			(R
				*
					{a.
					b.
					e}).
			(R
				*
					{a.
					c.
					e}).
			(R
				*
					{a.
					b.
					c.
					d})} asSet
]

{ #category : #'ideal basics' }
CommutativeAlgebraTest >> testZeroIdeal [
	| zero |
	zero := ZZ * #().	"the zero ideal {0}"
	self assert: zero isZero.
	self assert: (zero includes: 0).
	self deny: (zero includes: 42) 
]
