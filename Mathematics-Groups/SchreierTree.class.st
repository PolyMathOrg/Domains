"
Given a finite group G with a generating set S, and an action of G on X, a Schreier tree with root x for S is a representation of the orbit of x: it's a tree rooted at x with the elements of x^G as its vertices, and its edges describing the elements of S needed to get from x to each vertex, i.e. each edge {i,j} in the tree with i closer to the root than j is labeled by a generator s in S moving i to j.

Schreier trees allow for fast computation of stabilizers by Schreier's Lemma: with the notation above, the stabilizer of x is generated by the set of Schreier generators <t(i) * s * t(s(i))^-1> where i runs over the the orbit of x, s runs over the generating set S, and t(i) is an element of G moving x to i, i.e. a coset representative of i (see >>trace: and >>traceInverse:).

"
Class {
	#name : #SchreierTree,
	#superclass : #Object,
	#instVars : [
		'root',
		'generators',
		'action',
		'v',
		'inverses',
		'w',
		'orbit'
	],
	#category : #'Mathematics-Groups-Algorithms'
}

{ #category : #'instance creation' }
SchreierTree class >> root: aPoint generators: anArray action: aGroupAction [
	^ self new root: aPoint generators: anArray action: aGroupAction
]

{ #category : #accessing }
SchreierTree >> orbit [
	^ orbit
]

{ #category : #initialization }
SchreierTree >> root: aPoint generators: anArray action: aGroupAction [
	| queue |
	root := aPoint.
	generators := anArray.
	action := aGroupAction.
	v := Dictionary new. "Schreier vector"
	w := Dictionary new. "backward pointers"
	inverses := Dictionary new. "inverses of the Schreier generators from v"
	orbit := Set with: aPoint.
	v at: aPoint put: nil. "-1"
	w at: aPoint put: nil. "-1"
	queue := OrderedCollection with: aPoint.
	[| a |
	a := queue removeFirst.
	1 to: generators size do: [:i|
		| x g |
		g := generators at: i.
		x := action value: {g. a}.
		(orbit includes: x)
			ifFalse:
				[orbit add: x.
				queue add: x.
				v at: x put: g.
				w at: x put: a]].
	queue isEmpty] whileFalse
]

{ #category : #accessing }
SchreierTree >> stabilizer [
	"Answer the stabilizer of the root."
	| stabilizerGenerators id |
	stabilizerGenerators := Set new.
	id := action group identity.
	self orbit do: [:i|
		generators do: [:s|
			| g |
			g := (self traceInverse: (s value: i)) * s * (self trace: i).
			g = id ifFalse: [stabilizerGenerators add: g]]].
	^ action group span: stabilizerGenerators
]

{ #category : #accessing }
SchreierTree >> trace: aPoint [
	"Trace the Schreier spanning tree (v,w) for the orbit containing aPoint.
	Answer the transversal u(aPoint), i.e. an element such that root^u(aPoint) = aPoint.
	This is the representative function, and in particular u(root^h) is a representative of the coset G_root * h, where G_root is the stabilizer at the root of this Schreier tree.
	For an element g in G, there's an h in G_root g = h * u(root^g), and h = h * u(root^h)^-1."
	| alpha u |
	u := action group identity.
	alpha := aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u := u * (v at: alpha).
			alpha := w at: alpha].
	^ u
]

{ #category : #accessing }
SchreierTree >> traceInverse: aPoint [
	"Calculate inverses of coset representatives. See 'The Schreier-Sims Algorithm' pp 18. Assumes we're using a (strong) generating set that is closed under inversion. This makes backward pointers unnecesary."
	| alpha u |
	u := action group identity.
	alpha := aPoint.
	[(v at: alpha) notNil]
		whileTrue:
			[u := (inverses at: alpha ifAbsentPut: [(v at: alpha) inverse]) * u.
			alpha := w at: alpha].
	^ u
]

{ #category : #private }
SchreierTree >> verify [
	^ self stabilizer generators allSatisfy: [:each| (each value: root) = root]
]
